class CL_ABAP_BEHV_CTRL definition
  public
  final
  create public

  global friends CL_ABAP_BEHVDESCR
                 CL_ABAP_BEHV_DETVAL
                 CL_ABAP_BEHV_HANDLER_PROJ
                 CL_ABAP_BEHV_JOB
                 CL_ABAP_BEHV_JOB_BASE
                 CL_ABAP_BEHV_LOG
                 CL_ABAP_BEHV_SAVER_PROJ
                 CL_ABAP_BEHV_TEST_ENVIRONMENT
                 CL_ABAP_BEHV_TRANSACTION_CTRL .

public section.

  types:
    t_pool_name type c length 30 .
  types T_SERIAL_KEY type XSTRING .
  types TT_POOL_UNIQ type CL_ABAP_BEHV_JOB_BASE=>TT_POOL_UNIQ .
  types TT_ENTITY_UNIQ type ABP_ENTITY_NAME_TAB .
  types:
    tt_pool_name_uniq type sorted table of t_pool_name with unique key table_line .
  types:
    begin of t_handler_param,
      " ---------------- kernel expects these components in this order
      param_idx  type i,
      " equal component names serve move-corresponding
      instances  type abp_behv_activities-instances,  " REF TO DATA
      results    type abp_behv_activities-results,    " REF TO DATA
      result_idx type i,
      full       type abp_behv_activities-full,       " L:RBA-Links, R:RBA-Results
      op         type abp_behv_activities-op,
      links      type abp_behv_activities-links,      " REF TO DATA
      " ---------------- end of components passed to invocation
      actv_idx   type i,
    end of t_handler_param .
  types:
    tt_handler_param type standard table of t_handler_param with empty key .
  types:
    begin of t_handler_context,
      entity_name type ABP_BEHV_ACTIVITIES-ENTITY_NAME,
      sub_name    type ABP_BEHV_ACTIVITIES-SUB_NAME,
    end of t_handler_context .
  types:
    begin of t_handler,
      root          type abp_root_entity_name,
      pool_name     type d010behv-clsname,
      handler_idx   type i,  " local-class index
      handler       type ref to cl_abap_behavior_handler,
      params        type tt_handler_param,
      context       type t_handler_context,  " for validation
    end of t_handler .
  types:
    tt_handler type standard table of t_handler with empty key .
  types TT_D010BEHV type CL_ABAP_BEHV_JOB_BASE=>TT_BEHAVIOR_TRIG_SORT .
  types: begin of enum t_finalize_status base type c,
      co_finalize_not_run value is initial, " initial run still needed
      co_finalize_done    value 'X',        " has run at least once
      co_finalize_repeat  value '+',        " additional run needed
    end of enum t_finalize_status.
  types:
    begin of t_saver,
      root            type abp_root_entity_name,
      pool_name       type d010behv-clsname,
      saver_idx       type i,  " local-class index
      acc_direct      type c length 1,
      acc_modify      type c length 1,
      finalize_multi  type c length 1,  " can this saver's FINALIZE be repeated?
      finalize_status type t_finalize_status, " has FINALIZE already been executed?
      saver           type ref to cl_abap_behavior_saver,
    end of t_saver .
  types:
    tt_saver type standard table of t_saver with empty key .
  types:
    t_timestamp type c length 14 .
  types:
    begin of t_response,
           rootname   type abp_root_entity_name,
           r_failed   type ref to data,
           r_reported type ref to data,
           log        type ref to cl_abap_behv_log,
         end of t_response .
  types:
    tt_response type sorted table of t_response with unique key rootname .
  types: begin of t_real_name,
           orig type abp_entity_name,
           real type abp_entity_name,
         end of t_real_name.
  types: tt_real_name type hashed table of t_real_name with unique key orig
                           with non-unique sorted key kr components real.
  types:
    begin of enum T_MANAGED_KIND structure MK,
           CSP_ACTIVE value is initial,
           CSP_DRAFT  value 1,
           BSP_DRAFT  value 2,
           PROJECTION value 3,
           MOCKED     value 4,
           PROJ_D_CSP value 5,  " projection on CSP draft
           PROJ_D_BSP value 6,  " projection on BSP draft
           DVM_ACTIVE value 7,  " determine actions on active instances
           DVM_DRAFT  value 8,  " determine actions on draft instances
           BSP_ACTIVE value 9,
         end of enum T_MANAGED_KIND structure MK .
  types:
    t_exempt_value type x length 2 .  " [1]: kernel, [2]: extended (SADL)
  types:
    begin of t_exempt,
           name type abp_root_entity_name,
           x    type t_exempt_value,
         end of t_exempt .
  types:
    tt_exempt type hashed table of t_exempt with unique key name .
  types:
    begin of t_relation_key_mapping, " "parallel arrays": corresponding entries in SOURCE and TARGET have same index
      source_entity type abp_entity_name,
      target_entity type abp_entity_name,
      source type ref to data, " TABLE FOR READ IMPORT <source entity>
      target type ref to data, " TABLE FOR READ IMPORT <target entity>
    end of t_relation_key_mapping .
  types:
    tt_relation_key_mapping type sorted table of t_relation_key_mapping with unique key source_entity .

  constants EX__NULL type T_EXEMPT_VALUE value IS INITIAL ##NO_TEXT.
  constants EX_CD type T_EXEMPT_VALUE value '0100' ##NO_TEXT.
  constants EX_CS type T_EXEMPT_VALUE value '0200' ##NO_TEXT.
  constants EX_CFIUT type T_EXEMPT_VALUE value '0400' ##NO_TEXT.
  constants EX_SR type T_EXEMPT_VALUE value '0800' ##NO_TEXT.
  constants EX_CFIBU type T_EXEMPT_VALUE value '1000' ##NO_TEXT.
  constants EX_LF type T_EXEMPT_VALUE value '0001' ##NO_TEXT.
  constants EX_CQD type T_EXEMPT_VALUE value '0002' ##NO_TEXT.
  constants EX_STS type T_EXEMPT_VALUE value '0004' ##NO_TEXT.
  constants EX_SNC type T_EXEMPT_VALUE value '0008' ##NO_TEXT.
  constants EX_TTX type T_EXEMPT_VALUE value '0010' ##NO_TEXT.
  constants:
    flag_provided type x length 1 value '01' ##NO_TEXT. " -- keep -- used by EML compilation!
  constants:
    begin of mki,
               CSP_ACTIVE type i value is initial,  " = - mk-CSP_ACTIVE
               CSP_DRAFT  type i value -1,          " = - mk-CSP_DRAFT
               BSP_DRAFT  type i value -2,          " = - mk-BSP_DRAFT
               PROJECTION type i value -3,          " = - mk-PROJECTION
               MOCKED     type i value -4,          " = - mk-MOCKED
               PROJ_D_CSP type i value -5,          " = - mk-PROJ_D_CSP
               PROJ_D_BSP type i value -6,          " = - mk-PROJ_D_BSP
               DVM_ACTIVE type i value -7,          " = - mk-DVM_ACTIVE
               DVM_DRAFT  type i value -8,          " = - mk-DVM_DRAFT
               BSP_ACTIVE type i value -9,          " = - mk-BSP_ACTIVE
               MISSING    type i value -10,         " = - mk-MISSING Missing handler
    end of mki .
  constants NOT_IMPLEMENTED type I value -1 ##NO_TEXT.
  constants IMPLEMENTED_MANAGED type I value -2 ##NO_TEXT.
  constants IMPLEMENTED_MOCKED type I value -4 ##NO_TEXT.
  constants:
    begin of op,
      unknown     type abp_behv_op value ' ',
      create      type abp_behv_op value 'C',
      update      type abp_behv_op value 'U',
      delete      type abp_behv_op value 'D',
      action      type abp_behv_op value 'A',
      evaluate    type abp_behv_op value 'E',  "< read-only action ([E]valuate)
      read        type abp_behv_op value 'R',
      read_ba     type abp_behv_op value 'N',  "< read-by-association   ([N]avigate)
      create_ba   type abp_behv_op value 'O',  "< create-by-association ([O]riginate)
      lock        type abp_behv_op value 'L',
      determine   type abp_behv_op value 'd',
      validate    type abp_behv_op value 'v',
      lock_edit   type abp_behv_op value 'z',  "< lock-for-edit
      augm_create type abp_behv_op value 'c',
      augm_update type abp_behv_op value 'u',
      augm_crt_ba type abp_behv_op value 'g',
      precheck    type abp_behv_op value 'P',
    end of op .
  constants:
    begin of d010behv_op,
      real            like op          value op,
      begin of pseudo,  " pseudo-operations occurring as values in D010BEHV-OPERATION
        meta          type abp_behv_op value 'M',
        save          type abp_behv_op value 'S',
        order         type abp_behv_op value 'o',
        icontrol      type abp_behv_op value 'I',  "< per-instance feature control
        gcontrol      type abp_behv_op value 'G',  "< global feature control
        iauthority    type abp_behv_op value 'a',  "< per-instance authorization
        gauthority    type abp_behv_op value 'J',  "< global authorization
        action_ind    type abp_behv_op value 'x',  "< action indirect
        evaluate_ind  type abp_behv_op value 'y',  "< function indirect
        permissions   type abp_behv_op value 'P',  "< Permissions
      end of pseudo,
      begin of virtual,  " values not even occurring in D010BEHV
        failed        type abp_behv_op value 'F',
        mapped        type abp_behv_op value 'M',
        reported      type abp_behv_op value 'P',
        failed_late   type abp_behv_op value 'f',
        mapped_late   type abp_behv_op value 'm',
        reported_late type abp_behv_op value 'p',
        primarykey    type abp_behv_op value 'k',
        pkey          type abp_behv_op value 'q',
        tkey          type abp_behv_op value 'u',
        mngdbuffer    type abp_behv_op value 'b',
        mngdcontent   type abp_behv_op value 'o',
        mngdlockarg   type abp_behv_op value 'l',
        mngddraftbuff type abp_behv_op value 'e',
        " DO NOT ADD FURTHER CODES FOR *TYPES* HERE
      end of virtual,
    end of d010behv_op .
  constants:
    begin of typekind,
      importing type abp_behv_typekind value ' ',
      returning type abp_behv_typekind value 'R',
      link      type abp_behv_typekind value 'L',
    end of typekind .
  constants:
    begin of get_descr_rc,
        ok type i value 0,              "< OK
        reloaded type i value 4,        "< table reloaded from DB
        not_found type i value 8,       "< BDI load not found
        db_not_found type i value 12,   "< SELECT error
        error type i value 16,          "< PXA error
        no_mem type i value 20,         "< Out of Memory
    end of get_descr_rc .
  constants:
    C_IMPL_REQ_ACTIVE type c length 1 value '!' ##NO_TEXT.
  constants:
    C_IMPL_REQ_DRAFT  type c length 1 value '?' ##NO_TEXT.
  class-data:
    mki_proj       type range of i read-only .
  class-data:
    mki_proj_draft type range of i read-only .
  class-data:
    mki_draft      type range of i read-only .

  class-methods CLASS_CONSTRUCTOR .
  class-methods CALL_COLLECTED_SAVERS
    importing
      !PHASE type IF_ABAP_BEHV=>T_PHASE
      !LOG type ref to IF_ABAP_BEHV_LOG
    exporting
      !UNHANDLED_ROOTS type TT_ENTITY_UNIQ .
  class-methods CALL_HANDLER
    importing
      !HANDLER type ref to CL_ABAP_BEHAVIOR_HANDLER
      !PARAMS type ref to TT_HANDLER_PARAM
      !ROOT type ABP_ROOT_ENTITY_NAME
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !FAIL_LOG type ref to IF_ABAP_BEHV_LOG optional
      !SMSG_LOG type ref to IF_ABAP_BEHV_LOG optional .
  class-methods CALL_INSTANCE_CONTROLLERS
    importing
      !JOB type ref to CL_ABAP_BEHV_FJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_AUTHORITY_CHECKS
    importing
      !JOB type ref to CL_ABAP_BEHV_AJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_GLOBAL_AUTHORIZATION
    importing
      !JOB type ref to CL_ABAP_BEHV_GAJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_PRECHECKERS
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_READERS
    importing
      !JOB type ref to CL_ABAP_BEHV_RJOB
      !IMAGE type IF_ABAP_BEHV=>T_IMAGE optional
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_EARLY_NUMBERING
    importing
      !JOB type ref to CL_ABAP_BEHV_NJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods CALL_SAVER
    importing
      !SAVER type ref to CL_ABAP_BEHAVIOR_SAVER
      !PHASE type IF_ABAP_BEHV=>T_PHASE
      !ROOT type ABP_ROOT_ENTITY_NAME
      !LOG type ref to IF_ABAP_BEHV_LOG optional
    exporting
      !IS_VOID type SYCHAR01
      !DIRECT_FAILED type ref to DATA
      !DIRECT_MAPPED type ref to DATA
      !DIRECT_REPORTED type ref to DATA
    changing
      !REMOVED_ENTITIES type TT_ENTITY_UNIQ optional .
  class-methods CALL_PERMISSIONS
    importing
      !JOB type ref to CL_ABAP_BEHV_PJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods END_SAVER_COLLECTION .
  class-methods EXECUTE_COMMIT
    importing
      !RESPONSES type TT_RESPONSE optional
      !SCOPE type SYCHAR01 optional
      !DYNAMIC type SYCHAR01 optional
      !PARTIAL type SYCHAR01 optional
      !ROOT_NAMES type ABP_ENTITY_NAME_TAB optional
    exporting
      !RC type I .
  class-methods EXECUTE_CONVERT_PRE
    importing
      !ENTITY type ABP_ENTITY_NAME
      !PREKEY type DATA
      value(MODE) type SYCHAR01 default 'S'
    exporting
      !KEY type DATA
    changing
      !PREKEY_DYN type DATA optional
      !KEY_DYN type DATA optional .
  class-methods EXECUTE_INSTANCE_CONTROLLERS
    importing
      !JOB type ref to CL_ABAP_BEHV_FJOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !DYNAMIC type SYCHAR01 optional
      !KEEP_LOG type SYCHAR01 optional
    changing
      !FAILED type ANY optional
      !REPORTED type ANY optional .
  class-methods EXECUTE_PERMISSIONS
    importing
      value(JOB) type ref to CL_ABAP_BEHV_PJOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !DYNAMIC type SYCHAR01 optional
    changing
      !FAILED type ANY optional
      !REPORTED type ANY optional .
  class-methods EXECUTE_LOCK
    importing
      value(JOB) type ref to CL_ABAP_BEHV_JOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !DYNAMIC type SYCHAR01 optional
    changing
      !FAILED type ANY optional
      !MAPPED type ANY optional
      !REPORTED type ANY optional .
  class-methods EXECUTE_MODIFY
    importing
      value(JOB) type ref to CL_ABAP_BEHV_JOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !INTERNAL type SYCHAR01 optional
      !DYNAMIC type SYCHAR01 optional
    changing
      !FAILED type ANY optional
      !MAPPED type ANY optional
      !REPORTED type ANY optional .
  class-methods _EXECUTE_ACTIVATE
    importing
      value(JOB) type ref to CL_ABAP_BEHV_JOB_BASE
      !ROOT type ABP_ROOT_ENTITY_NAME optional
    returning
      value(ACTIVATE_DONE) type SYCHAR01 .
  class-methods _EXECUTE_INTERNAL_MODIFY
    importing
      value(JOB) type ref to CL_ABAP_BEHV_JOB
      !ROOT type ABP_ROOT_ENTITY_NAME
      !INTERNAL_MODE type CL_ABAP_BEHV_JOB_BASE=>T_INTERNAL_MODE optional.
  class-methods EXECUTE_READ
    importing
      value(JOB) type ref to CL_ABAP_BEHV_RJOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !IMAGE type IF_ABAP_BEHV=>T_IMAGE optional
      !INTERNAL type SYCHAR01 optional
      !DYNAMIC type SYCHAR01 optional
    changing
      !FAILED type ANY optional
      !REPORTED type ANY optional .
  class-methods _EXECUTE_INTERNAL_READ
    importing
      value(JOB) type ref to CL_ABAP_BEHV_RJOB
      !ROOT type ABP_ROOT_ENTITY_NAME
      !INTERNAL_MODE type CL_ABAP_BEHV_JOB_BASE=>T_INTERNAL_MODE optional .
  class-methods EXECUTE_ROLLBACK .
  class-methods GET_ENTITY_INDEX
    importing
      !ENTITY_NAME type ABP_ENTITY_NAME
      !ROOT_NAME type ABP_ROOT_ENTITY_NAME optional
    exporting
      !ENTITY_INDEX type I .
  class-methods GET_HANDLERS
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !KIND type ABP_BEHV_KIND optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
      !IGNORE_ORDERING type SYCHAR01 default ' '
    exporting
      !HANDLERS type TT_HANDLER
      !LOCK_HANDLERS type TT_HANDLER
      !ERROR_POOLS type TT_POOL_NAME_UNIQ
      !SAVERS type TT_SAVER .
  class-methods GET_SAVER_RESPONSE
    importing
      !SAVER type ref to CL_ABAP_BEHAVIOR_SAVER
      !PHASE type IF_ABAP_BEHV=>T_PHASE
    exporting
      !FAILED type ref to DATA
      !MAPPED type ref to DATA
      !REPORTED type ref to DATA
    returning
      value(FOUND) type SYCHAR01 .
  class-methods LOAD_IMPLEMENTATIONS
    importing
      !ROOT_ENTITY type TABNAME
      !NO_BUFFER type SYCHAR01 optional
      !NO_DUMP type SYCHAR01 optional
      !EXCLUDE type STRING optional
    exporting
      !TIMESTAMP type T_TIMESTAMP
      !RC type I
      !ENTRIES type I
      !CONTENT type TT_D010BEHV .
  class-methods RESET_SINGLETONS
    importing
      !HANDLERS type SYCHAR01 default 'X'
      !SAVERS type SYCHAR01 default 'X' .
  class-methods SET_SAVER_RESPONSE
    importing
      !SAVER type ref to CL_ABAP_BEHAVIOR_SAVER
      !PHASE type IF_ABAP_BEHV=>T_PHASE
      !FAILED type ref to DATA optional
      !MAPPED type ref to DATA optional
      !REPORTED type ref to DATA optional .
  class-methods START_SAVER_COLLECTION
    importing
      !COLLECTOR type ref to IF_ABAP_BEHV_SAVER_COLLECTOR optional .
  class-methods EXECUTE_GLOBAL_CONTROLLERS
    importing
      !JOB type ref to CL_ABAP_BEHV_GFJOB
      !ROOT type ABP_ROOT_ENTITY_NAME optional
      !DYNAMIC type SYCHAR01 optional
      !KEEP_LOG type SYCHAR01 optional .
  class-methods CALL_GLOBAL_CONTROLLERS
    importing
      !JOB type ref to CL_ABAP_BEHV_GFJOB
      !ALL_ROOT_ENTITIES type TT_ENTITY_UNIQ optional
      !HDLR_RESTRICTION type TT_POOL_UNIQ optional
    exporting
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods GET_EXEMPTIONS
    importing
      !REQ_VAL type T_EXEMPT_VALUE optional
    returning
      value(EXEMPTIONS) type TT_EXEMPT .
  class-methods IS_EXEMPTED
    importing
      !BDEF_NAME type ABP_ROOT_ENTITY_NAME
      !EXEMPTION type T_EXEMPT_VALUE
    returning
      value(IS_EXEMPTED) type SYCHAR01 .
protected section.

  types:
    begin of t_genkey,
           entity type string, "abp_entity_name,
           key    type t_serial_key,
           cid    type abp_behv_cid,
         end of t_genkey .
  types:
    begin of t_genref,
           ref_from type t_genkey,
           ref_to   type t_genkey,
         end of t_genref .
  types:
    tt_genref type sorted table of t_genref with non-unique key ref_from .

  constants OP_INDEX_FIXED type STRING value ` CUDRLzcu` ##NO_TEXT.
  " 1:[C]reate 2:[U]pdate 3:[D]elete 4:[R]ead 5:[L]ock 6:[z]LockForEdit
  " 7:[c]reateAugmented 8:[u]pdateAugmented
  constants IDX_LOCK type I value -5 ##NO_TEXT. " neg. position of 'L' in OP_INDEX_FIXED
  constants IDX_LOCK_EDIT type I value -6 ##NO_TEXT. " neg. position of 'z' in OP_INDEX_FIXED
  constants OP_CHARS_W_SUB type STRING value `AEONgvdxyIGajJ` ##NO_TEXT.  " ops with sub-name (action/assoc/validation/determination/icontrol/gcontrol/iauthority/gauthority)
  constants OP_CHARS_W_SUBT type STRING value `vd` ##NO_TEXT.  " ops with sub-name and trigger-name (validation/determination)
  constants OP_CHARS_ASSOC type STRING value `ONg` ##NO_TEXT.  " ops with assoc
  constants OP_CHARS_W_GRP type STRING value `GIJa` ##NO_TEXT. " ops with group (global/instance features/authorization)
  constants OP_CHARS_M type STRING value `CUDOAx` ##NO_TEXT.  " ops for MODIFY
  constants OP_CHARS_R type STRING value `RNEy` ##NO_TEXT.   " ops for READ
  constants OP_CHARS_NON_HDL type STRING value `LMSo` ##NO_TEXT.   " non-handler values in D010BEHV
  constants OP_CHARS_MERGE_ITAB type STRING value `Fa` ##NO_TEXT.
  constants OP_CHARS_MERGE_STRU type STRING value `GJ` ##NO_TEXT.
  constants OP_CHARS_NON_INST type STRING value `GJP` ##NO_TEXT.  " ops to be called w/o instances
  constants OP_CHARS_AUGMENTABLE type STRING value `CUO` ##NO_TEXT. " Create, Update, CBA
  constants OP_CHARS_AUGMENTING type STRING value `cug` ##NO_TEXT. " Create, Update, CBA
  constants OP_CH_AUGM_TO_REAL type STRING value `cCuUgO` ##NO_TEXT.
  constants OP_CH_REAL_TO_AUGM type STRING value `CcUuOg` ##NO_TEXT.

  class-methods READ_RELATION_KEY_MAPPING
    importing
      !ROOT type ABP_ROOT_ENTITY_NAME
      !RELATION type CL_ABAP_BEHV_LOAD=>T_RELAT
      !SOURCE type ANY TABLE
      !ATTRS_FROM type ref to CL_ABAP_BEHV_JOB_BASE optional
      !LOG type ref to IF_ABAP_BEHV_LOG optional
    exporting
      !MAPPING type T_RELATION_KEY_MAPPING
    changing
      !RJOB_IF_UNHANDLED type ref to CL_ABAP_BEHV_RJOB optional .
  class-methods ADD_INSTANCE_REFS
    importing
      !INST_REFS type TT_GENREF
      !BDEF type STRING .
  class-methods CHECK_TEST_DOUBLE_ALLOWED .
  class-methods GET_CALLER
    returning
      value(TADIR_KEY) type SABP_S_TADIR_KEY .
  class-methods SET_TEST_DOUBLE
    importing
      !OBJECT type ref to IF_ABAP_BEHAVIOR_TESTDOUBLE optional
      !UNREGISTER_ROOT type ABP_ROOT_ENTITY_NAME optional .
  class-methods GET_TEST_DOUBLE
    importing
      !ROOT type ABP_ROOT_ENTITY_NAME
    returning
      value(OBJECT) type ref to IF_ABAP_BEHAVIOR_TESTDOUBLE .
private section.

  types TT_BEHAVIOR_SORT type CL_ABAP_BEHV_JOB=>TT_BEHAVIOR_HDLR_SORT .
  types:
    begin of t_hdlr_par,          " one trigger parameter of a handler
           param_idx     type i,  " D010BEHV-IP (for invocation)
           actv_trig_idx type i,  " trigger index according to current activities (for algorithm)
           result_idx    type i,  " D010BEHV-IR (for invocation)
           name          type c length 30,  " parameter/action/assoc name
    end of t_hdlr_par .
  types:
    tt_hdlr_par type standard table of t_hdlr_par with default key
                     with non-unique sorted key actv components actv_trig_idx .
  types:
    begin of t_hdlr_sig,   " name (global/local) and signature of a handler
           clsname     type t_pool_name,
           handler_idx type i,  " D010BEHV-IC (local-class index)
           hdlmeth_idx type i,  " D010BEHV-IM (method vtab index)
           hdlparm_cnt type i,  " D010BEHV-NP (method form-param count)
           kind        type D010BEHV-kind,
           params      type tt_hdlr_par,
           root        type abp_root_entity_name,
           order_idx   type i,
           hlist_idx   type i,
         end of t_hdlr_sig .
  types:
    tt_hdlr_sig type standard table of t_hdlr_sig with default key .
  types:
    begin of t_trigger_handler.           " map trigger -> handler indices
           types:  actv_trig_idx type i.  " trigger index according to current activities
           types:  hdlr_idx      type i,  " handler index (into handler table)
         end of t_trigger_handler .
  types:
    tt_trigger_handler type sorted table of t_trigger_handler
                            with non-unique key actv_trig_idx .
  types:
                            "with unique key actv_trig_idx hdlr_idx.  " see comment in GROUP_BEHV_BY_CLSS
    begin of t_beho,
           kind        type d010behv-kind,     " ordering info kind
           clsname     type t_pool_name,
           handler_idx type i,
           order_idx   type i,                 " handler index within pool
           handlername type d010behv-handlername,
           op_info     type d010behv-op_info,  " target of order relation
         end of t_beho .
  types:
    tt_beho type sorted table of t_beho with non-unique key kind clsname handler_idx .
  types:
    begin of t_hdlr_instance,
           kind     type D010BEHV-kind,
           clsname  type t_pool_name,
           lclsidx  type i,
           methidx  type i,
           instance type ref to cl_abap_behavior_handler,
    end of t_hdlr_instance .
  types:
    tt_hdlr_instance type hashed table of t_hdlr_instance with unique key kind clsname lclsidx methidx .
  types:
    begin of t_savr_instance,
           clsname  type t_pool_name,
           lclsidx  type i,
           instance type ref to cl_abap_behavior_saver,
    end of t_savr_instance .
  types:
    tt_savr_instance type hashed table of t_savr_instance with unique key clsname lclsidx .
  types:
    begin of t_data_area,
           rootname type abp_entity_name,
           ref      type ref to data,
           in_use   type i,
    end of t_data_area .
  types:
    tt_data_area type sorted table of t_data_area with non-unique key rootname .
  types:
    begin of t_data_fallback_failed,
           entity type abp_entity_name,
           key    type string,
           fail   type if_abap_behv=>t_failinfo,
    end of t_data_fallback_failed .
  types:
    tt_data_fallback_failed type standard table of t_data_fallback_failed with empty key .
  types:
    begin of t_data_fallback_mapped,
           entity type abp_entity_name,
           cid    type abp_behv_cid,
           key    type string,
    end of t_data_fallback_mapped .
  types:
    tt_data_fallback_mapped type sorted table of t_data_fallback_mapped with non-unique key entity cid .
  types:
    begin of t_data_fallback_reported,
           entity type abp_entity_name,
           key    type string,
           msg    type if_abap_behv=>t_message,
    end of t_data_fallback_reported .
  types:
    tt_data_fallback_reported type sorted table of t_data_fallback_reported with non-unique key entity key .
  types:
    begin of t_data_fallback_entitykey,
           entity type abp_entity_name,
           key    type string,
    end of t_data_fallback_entitykey .
  types:
    tt_data_fallback_entitykey type sorted table of t_data_fallback_entitykey with non-unique key entity key .
  types:
    begin of t_entity_index,
           root_name   type ABP_ROOT_ENTITY_NAME,
           entity_name type ABP_ENTITY_NAME,  " NB: may be foreign to root
           index_in_bd type i,
         end of t_entity_index .
  types:
    begin of T_TRACE_HIER,
           NEST type if_sxt_types=>ty_hierarchy_number,
           MSG  type string,
         end of T_TRACE_HIER .
  types:
    begin of T_TRIGGER_TRACE,
           entity   type abp_entity_name,
           op       type abp_behv_op,
           is_draft type cl_abap_behv_job_base=>T_IS_DRAFT,
         end of T_TRIGGER_TRACE .
  types:
    TT_TRIGGER_TRACE type standard table of T_TRIGGER_TRACE with empty key .
  types T_TEXT type IF_SXT_TYPES=>TY_MESSAGE .

  class-data G_EXTAB type TT_EXEMPT .
  constants:
*  types:
*    begin of t_mapped_roots,
*           mapped_name type ABP_ROOT_ENTITY_NAME,
*           mapper_name type ABP_ROOT_ENTITY_NAME,
*         end of t_mapped_roots .
*  types:
*    tt_mapped_roots type hashed table of t_mapped_roots with unique key table_line .
    begin of c_meth_none ##NEEDED,
      finalize            type i value not_implemented,
      check_before_save   type i value not_implemented,
      adjust_numbers      type i value not_implemented,
      save                type i value not_implemented,
      cleanup             type i value not_implemented,
      cleanup_finalize    type i value not_implemented,
      save_modified       type i value not_implemented,
      map_messages        type i value not_implemented,
    end of c_meth_none .
  constants:
    begin of c_meth_managed ##NEEDED,
      finalize            type i value implemented_managed,
      check_before_save   type i value implemented_managed,
      adjust_numbers      type i value implemented_managed,
      save                type i value implemented_managed,
      cleanup             type i value implemented_managed,
      cleanup_finalize    type i value implemented_managed,
      save_modified       type i value not_implemented,
      map_messages        type i value not_implemented,
    end of c_meth_managed .
  constants:
    begin of c_meth_mocked ##NEEDED,
      finalize            type i value implemented_mocked,
      check_before_save   type i value implemented_mocked,
      adjust_numbers      type i value implemented_mocked,
      save                type i value implemented_mocked,
      cleanup             type i value implemented_mocked,
      cleanup_finalize    type i value implemented_mocked,
      save_modified       type i value not_implemented,
      map_messages        type i value implemented_mocked,
    end of c_meth_mocked .
  constants AREA_IS_SET type STRING value `%STATE_AREA IS NOT INITIAL` ##NO_TEXT. " CL_ABAP_BEHV=>CO_TECHFIELD_NAME-STATE_AREA
  " Texts for use in TRACE (intentionally in "Technical English")
"    text_001 type t_text value 'ABAP Behavior Controller',
  constants TEXT_002 type T_TEXT value 'Handlers' ##NO_TEXT.
  constants TEXT_003 type T_TEXT value 'Job Triggers' ##NO_TEXT.
  constants TEXT_004 type T_TEXT value 'Call' ##NO_TEXT.
  constants TEXT_005 type T_TEXT value 'Map Messages' ##NO_TEXT.
  constants TEXT_006 type T_TEXT value 'Precheck' ##NO_TEXT.
  constants TEXT_007 type T_TEXT value 'EML' ##NO_TEXT.
  constants TEXT_008 type T_TEXT value 'Message Mappers' ##NO_TEXT.
  constants TEXT_009 type T_TEXT value 'Active/Draft Handlers' ##NO_TEXT.
  constants TEXT_010 type T_TEXT value 'Cyclic FINALIZE repetition:' ##NO_TEXT.
  class-data SAVER_COLLECTOR type ref to IF_ABAP_BEHV_SAVER_COLLECTOR .
  class-data SAVER_EXECUTION type INT4 .
  class-data ROOTS_MODIFIED type TT_REAL_NAME .
  class-data HDLR_INSTANCES type TT_HDLR_INSTANCE .
  class-data SAVR_INSTANCES type TT_SAVR_INSTANCE .
  class-data:
    BUSY_HDLR_INSTANCES type hashed table of ref to CL_ABAP_BEHAVIOR_HANDLER with unique key table_line .
  class-data MOCK_INSTANCES type CL_ABAP_BEHV_JOB_BASE=>TT_MOCK_INSTANCE .
  class-data MOCK_ENTITIES type ABP_ENTITY_ROOT_TAB .
  class-data DATA_AREA_FAILED type TT_DATA_AREA .         " for MODIFY
  class-data DATA_AREA_MAPPED type TT_DATA_AREA .         " for MODIFY
  class-data DATA_AREA_REPORTED type TT_DATA_AREA .       " for MODIFY
  class-data DATA_AREA_FAILED_LATE type TT_DATA_AREA .    " for FINALIZE etc.
  class-data DATA_AREA_MAPPED_LATE type TT_DATA_AREA .    " for ADJUST_NUMBERS, FINALIZE etc.
  class-data DATA_AREA_REPORTED_LATE type TT_DATA_AREA .  " for FINALIZE etc.
  class-data DATA_AREA_ENTITYKEY type TT_DATA_AREA .      " for LOCK
  class-data CURR_PROJ_HDLR type ref to CL_ABAP_BEHV_HANDLER_PROJ .
  class-data CURR_SAVER type ref to CL_ABAP_BEHAVIOR_SAVER .
  class-data:
    _ABSOLUTE_NAME type C length 70 .
  class-data EML_PROCESSOR type ref to IF_RAP_EML_PROCESSOR .
  class-data EML_CONVERTER type ref to IF_RAP_BHV_PRELIM_KEY_CONVERT .
  class-data _CONV_RC type I .
  class-data CURR_RESPONSES type TT_RESPONSE .
  class-data CURR_RESPONSES_GENLOG type ref to CL_ABAP_BEHV_LOG .
  class-data:
    M_ENTITY_INDICES type hashed table of t_entity_index with unique key root_name entity_name .
  constants NO_LOG type ref to IF_ABAP_BEHV_LOG value IS INITIAL ##NO_TEXT.

  class-methods CHECK_COMPATIBLE_FIELDS
    importing
      !FIELD1 type DATA
      !FIELD2 type DATA
    exporting
      !RC type I .
  class-methods CLEANUP_KRN .
  class-methods GET_HANDLER
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !HSIG type T_HDLR_SIG
    changing
      !HDLR type T_HANDLER .
  class-methods GET_HANDLERS_IN_ACTV_ORDER
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !ACTV_TRIGS type CL_ABAP_BEHV_JOB_BASE=>TT_ACTIVITY_IDX
      !TRIG_HDLRS type TT_TRIGGER_HANDLER
      !KIND type ABP_BEHV_KIND optional
    exporting
      !HANDLERS type TT_HANDLER
    changing
      !HDLR_SIGS type TT_HDLR_SIG
      !ERROR_POOLS type TT_POOL_NAME_UNIQ
      !UNHANDLED type CL_ABAP_BEHV_JOB_BASE=>TT_ACTIVITY_IDX .
  class-methods GET_IMPLEMENTATIONS_KRN
    importing
      !ROOT_ENTITY type TABNAME
      !NO_BUFFER type SYCHAR01 default ' '
      !KIND_POS type D010BEHV-KIND optional
      !KIND_NEG type D010BEHV-KIND optional
    exporting
      !TIMESTAMP type T_TIMESTAMP
      !RC type I
    changing
      !IMPL_OPS type TT_D010BEHV optional
      !IMPL_ORDER type TT_D010BEHV optional
      !IMPL_LOCK type TT_D010BEHV optional .
  class-methods GET_SAVER
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      value(METH) type CL_ABAP_BEHAVIOR_SAVER=>T_METH
    changing
      !SAVR type T_SAVER .
  class-methods GROUP_BEHV_BY_CLSS
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !COLLECT_SAVERS type SYCHAR01
    exporting
      !HANDLER_SIGS type TT_HDLR_SIG
      !SAVERS type TT_SAVER
      !TRIGGER_HANDLERS type TT_TRIGGER_HANDLER
      !TRIGGER_LOCK_HANDLERS type TT_TRIGGER_HANDLER
    changing
      !ERROR_POOLS type TT_POOL_NAME_UNIQ .
  class-methods INSTANTIATE_HANDLER
    importing
      !POOL_NAME type T_POOL_NAME
      !HDLCLSS_IDX type INT4
    exporting
      !HANDLER type ref to CL_ABAP_BEHAVIOR_HANDLER .
  class-methods INSTANTIATE_SAVER
    importing
      !POOL_NAME type T_POOL_NAME
      !SAVCLSS_IDX type INT4
    exporting
      !SAVER type ref to CL_ABAP_BEHAVIOR_SAVER .
  class-methods TRANSFER_TO_LOG
    importing
      !LOG type ref to IF_ABAP_BEHV_LOG
      !OTHER_LOG type ref to IF_ABAP_BEHV_LOG optional
      !SMSG_LOG type ref to IF_ABAP_BEHV_LOG optional
      value(KIND) type IF_ABAP_BEHV_LOG=>T_KIND
      !ROOT_NAME type ABP_ROOT_ENTITY_NAME
      !ENTITY_NAME type DATA
      !DISCARD_AFTERWARDS type SYCHAR01 optional
      !FLAVOR type IF_ABAP_BEHV_LOG=>T_FLAVOR optional
      !PHASE type IF_ABAP_BEHV=>T_PHASE optional
      !CURRENTLY_MAPPED type STRING optional
      !DO_MAP_MESSAGES type SYCHAR01 default 'X'
      !SET_MESSAGES_GLOBAL type SYCHAR01 optional
      !REJECT_STATE_MESSAGES type SYCHAR01 optional
    exporting
      !REMOVED_ENTITIES type TT_ENTITY_UNIQ
    changing
      !SRC_STRUC type DATA .
  class-methods GET_EML_COMMIT_LOG
    importing
      !ROOT type ABP_ROOT_ENTITY_NAME
    returning
      value(LOG) type ref to IF_ABAP_BEHV_LOG .
  class-methods OBJECTDESCR
    importing
      !OBJ type ref to OBJECT
    returning
      value(NAME) type STRING .
  class-methods LINECOUNT
    importing
      !STRUC type DATA
    returning
      value(COUNT) type I .
  class-methods KINDSTRING
    importing
      !KIND type ABP_BEHV_KIND
    returning
      value(STR) type STRING .
  class-methods MERGE_HANDLER_RESULTS
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
      !HANDLER type ref to CL_ABAP_BEHAVIOR_HANDLER
      !PARAMS type ref to TT_HANDLER_PARAM .
  class-methods SPLIT_DSP_HANDLER
    importing
      !JOB type ref to CL_ABAP_BEHV_JOB_BASE
    changing
      !HANDLERS type CL_ABAP_BEHV_CTRL=>TT_HANDLER .
  class-methods GET_1ST_SAVER_CALL_CYCLE
    importing
      !CURR type ref to CL_ABAP_BEHAVIOR_SAVER
      !FIND type ref to CL_ABAP_BEHAVIOR_SAVER
    returning
      value(CYCLE) type STRING .
  class-methods CHECK_SWITCHES_FOR_PERMISSIONS
    importing
      !ACTIVITIES type ABP_BEHV_ACTIVITIES_TAB .
ENDCLASS.



CLASS CL_ABAP_BEHV_CTRL IMPLEMENTATION.


method EXECUTE_READ.

data log type ref to cl_abap_behv_log.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

if job->m_internal is initial. " %_INTERNAL: suppress trace
  xtrace_beg_hier_eml th 'Read' 'EXECUTE_READ' dynamic internal ##NO_TEXT.
endif.

if failed   is supplied or
   reported is supplied .
  " ==== clear EML response fields
  clear failed.
  clear reported.
  " ==== create LOG object for transfer to EML response fields
  log = cl_abap_behv_log=>create_for_eml(
        exporting
          root         = root
          ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
          ref_reported = cond #( when reported is supplied then ref data( reported ) )
          dynamic      = dynamic
        ).
endif.

job->log = log.

switch_intf_base 'R'.

eml_call_pre.

data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
if job->m_internal is initial.
  cl_abap_behv_job_base=>curr_eml_job = job.
endif.

" split mixed activities before passing job to SADL
job->disentangle( importing entangled_refs = data(erefs) ).

get_eml_processor.
eml_processor->read( io_rjob  = job
                     iv_image = image ).

" merge result tables of split activities
job->entangle( erefs ).

switch_base_intf 'R'.

if job->m_internal is initial.
  cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.
  xtrace_end_hier th.
endif.

eml_call_post.

endmethod.


method EXECUTE_ROLLBACK.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

xtrace_beg_hier_eml th 'Rollback' 'EXECUTE_ROLLBACK' 0 0 ##NO_TEXT.

" === Pause transaction control
cl_abap_behv_transaction_ctrl=>pause( ).

get_eml_processor.

eml_processor->discard_changes( ).

" === Resume transaction control
cl_abap_behv_transaction_ctrl=>resume( ).

xtrace_end_hier th.

endmethod.


  method GET_CALLER.

    data(l_stack) = cl_abap_get_call_stack=>format_call_stack_with_struct( cl_abap_get_call_stack=>get_call_stack( ) ).

    data first_good_key like tadir_key.
    loop at l_stack assigning field-symbol(<s>).

      data l_previous_prog like <s>-progname.
      if <s>-progname eq l_previous_prog.
        continue.
      endif.
      l_previous_prog = <s>-progname.

      data l_devclass type tadir-devclass.
      clear l_devclass.
      clear tadir_key.

      if <s>-progname+30(1) is not initial.
        case <s>-progname+30(1).
          when 'C'.
            "class pool
            if <s>-progname eq 'CL_ABAP_BEHVDESCR=============CP'.
              continue.
            endif.
            tadir_key-obj_type = 'CLAS'.
          when 'B'.
            "bdef
            tadir_key-obj_type = 'BDEF'.
          when 'X'.
            "xslt
            tadir_key-obj_type = 'XSLT'.
          when others.
            continue.
        endcase.

        if <s>-progname cs '='.
          replace section offset sy-fdpos of <s>-progname with ' '.
        else.
          clear <s>-progname+30.
        endif.
        tadir_key-obj_name = <s>-progname.

      elseif <s>-progname(4) eq 'SAPL'.
        "fugr
        tadir_key-obj_type = 'FUGR'.
        tadir_key-obj_name = <s>-progname+4.

      elseif <s>-progname(1) eq '/' and <s>-progname+2 cs '/SAPL'.
        "fugr with namespace
        data(off) = sy-fdpos + 3.
        tadir_key-obj_type = 'FUGR'.
        tadir_key-obj_name = |{ <s>-progname(off) }{ substring( val = <s>-progname off = off + 4 ) }|.

      else.
        if <s>-progname(7) = 'SAPMSSY'.
          " reached bottom in rfc/vb/... really system
          exit.
        endif.
        tadir_key-obj_type = 'PROG'.
        tadir_key-obj_name = <s>-progname.
      endif.

      if tadir_key-obj_type is not initial and
         tadir_key-obj_name is not initial.
        select single devclass from tadir
          where  pgmid = 'R3TR' and
                 object = @tadir_key-obj_type and
                 obj_name = @tadir_key-obj_name
           into @l_devclass.

        if l_devclass is not initial.
          if l_devclass eq 'SABP_BEHV'. continue. endif. "RAP runtime
          if first_good_key is initial.
            first_good_key = tadir_key.
          endif.
          if l_devclass eq 'SBOI_RAP_RT_ENTITY'. continue. endif. "SADL runtime
          if contains( val = l_devclass start = 'SBOI_RAP_CSP' ) and not
             ( contains( val = l_devclass sub = '_TST' ) OR contains( val = l_devclass sub = '_TEST' ) ). continue. endif. "CSP runtime
          if l_devclass eq '/BOBF/RAP'. continue. endif. "BOFF runtime

          return.
        endif.

      endif.

    endloop.
    tadir_key = first_good_key.

  endmethod.


method GET_EML_COMMIT_LOG.

get_eml_commit_log log root.

endmethod.


method GET_ENTITY_INDEX.

data inc_name     type program.
data enames_cname type string.
data entity_idx   like line of m_entity_indices.
field-symbols <enames_struc> type data.

assign m_entity_indices[ root_name = root_name entity_name = entity_name ] to field-symbol(<entity_idx>).
if sy-subrc = 0.
  entity_index = <entity_idx>-index_in_bd.
  return.
endif.

entity_index = 0.

if root_name is not initial.
  " --- caller knows root (we trust it)
  inc_name = root_name.
else.
  inc_name = cl_abap_behvdescr=>get_root( p_entity = entity_name ).
endif.

overlay inc_name with '==============================BD'.
perform nottobefound in program (inc_name) if found.  " load BD into PXA
enames_cname = |({ inc_name })ENTITYNAME|.
assign (enames_cname) to <enames_struc>.  " find structured constant in BD
if sy-subrc <> 0.
  return.
endif.

" === Order of entities in constant = order in response structures
entity_idx-root_name = root_name.
do.
  entity_idx-index_in_bd = sy-index.
  assign component entity_idx-index_in_bd
   of structure <enames_struc> to field-symbol(<ename_comp>).
  if sy-subrc <> 0.
    exit.
  endif.
  entity_idx-entity_name = <ename_comp>.
  insert entity_idx into table m_entity_indices.
enddo.

" final entry for "%OTHERS"
clear  entity_idx-entity_name.
insert entity_idx into table m_entity_indices.

assign m_entity_indices[ root_name = root_name entity_name = entity_name ] to <entity_idx>.
if sy-subrc = 0.
  entity_index = <entity_idx>-index_in_bd.
endif.

*data(must_load) = xsdbool( m_curr_enames is initial ).
*if root_name is not initial.
*  " --- caller knows root (we trust it)
*  if m_curr_bd_name <> root_name.
*    must_load = 'X'. clear m_curr_enames.
*    m_curr_bd_name = root_name.
*  endif.
*else.
*  " --- must determine root first
*  try.
*    data(det_root_name) = cl_abap_behvdescr=>get_root( p_entity = entity_name ).
*    if m_curr_bd_name <> det_root_name.
*      must_load = 'X'. clear m_curr_enames.
*      m_curr_bd_name = det_root_name.
*    endif.
*  catch cx_abap_behvdescr.
*    return.
*  endtry.
*endif.
*
*
*if must_load is initial.
*  assign m_curr_enames->* to <enames_struc>.
*else.
*  data(inc_name) = conv program( m_curr_bd_name ).
*  overlay inc_name with '==============================BD'.
*  perform nottobefound in program (inc_name) if found.  " load BD into PXA
*  enames_cname = |({ inc_name })ENTITYNAME|.
*  assign (enames_cname) to <enames_struc>.
*  if sy-subrc <> 0.
*    return.
*  endif.
*  m_curr_enames = ref #( <enames_struc> ).
*endif.
*
*
*" === Order of entities in constant = order in response structures
*do.
*  assign component sy-index of structure <enames_struc> to field-symbol(<ename_comp>).
*  if sy-subrc <> 0.
*    return.
*  endif.
*  if <ename_comp> = entity_name.
*    entity_index = sy-index. return.
*  endif.
*enddo.


*if must_load is not initial.
*  clear m_curr_bd_entities.
*  cl_abap_behv_load=>get_load( exporting entity      = entity_name  all = 'X'
*                               importing entities    = m_curr_bd_entities
*                               changing  root_entity = m_curr_bd_name ).
*endif.
*
*" === Order of entities in load table = order in response structures !!
*loop at m_curr_bd_entities assigning field-symbol(<ent>).
*  if <ent>-name = entity_name.
*    entity_index = sy-tabix.
*    return.
*  endif.
*endloop.

endmethod.


method GET_HANDLER.

data hdlr_gen  type ref to CL_ABAP_BEHV_HANDLER_GENERIC.
data hdlr_proj type ref to CL_ABAP_BEHV_HANDLER_PROJ.
data hdlr_mock type ref to CL_ABAP_BEHV_HANDLER_MOCK.
data saver     type ref to CL_ABAP_BEHV_SAVER_PROJ.
data hdlr_proj_prec type ref to CL_ABAP_BEHV_HANDLER_PROJ.

field-symbols <clsname> type c.

data(handler_idx) = hsig-handler_idx.
if handler_idx < -31768.
  add 32768 to handler_idx.
endif.
data(is_generic)  = xsdbool( handler_idx <= 0 ). " %MANAGED, %MOCKED

" --- Determine key (part) CLSNAME for singleton cache
if is_generic is initial.
  assign hsig-clsname to <clsname>.  " unmanaged: singleton per handler class
else.
  assign hsig-root    to <clsname>.  " generic/managed: singleton per root
  if hsig-handler_idx in mki_proj_draft.
    handler_idx = mki-projection.
  endif.
endif.

" --- Try singleton cache
assign hdlr_instances[ kind    = hsig-kind
                       clsname = <clsname>
                       lclsidx = hsig-handler_idx "NOT: handler_idx
                       methidx = hsig-hdlmeth_idx
                     ]
  to field-symbol(<inst>).

data(busy) = xsdbool( sy-subrc = 0 and
                      line_exists( busy_hdlr_instances[ table_line = <inst>-instance ] ) ).

if sy-subrc = 0 and busy is initial.

  hdlr-handler = <inst>-instance.
"  hdlr-handler->kind = hsig-kind.
  hdlr-handler->meth = hsig-hdlmeth_idx.
  hdlr-handler->pcnt = hsig-hdlparm_cnt.
  if handler_idx = mki-projection.
    hdlr_proj = cast #( hdlr-handler ).  " prepare below
  endif.

else.

  if is_generic is not initial.

    case handler_idx.
      when mki-projection.
        hdlr_proj = new CL_ABAP_BEHV_HANDLER_PROJ(
          proj_root = hsig-root
          is_draft = cond #( when hsig-handler_idx in mki_proj_draft then if_abap_behv=>mk-on ) ).
        hdlr_gen = hdlr_proj.

      when mki-mocked.
        assign mock_instances[ root_name = hsig-root ] to field-symbol(<mock>).
        assert sy-subrc = 0.
        hdlr_mock = new CL_ABAP_BEHV_HANDLER_MOCK( ).
        hdlr_mock->m_object = <mock>-object.
        hdlr_gen = hdlr_mock.

      when mki-bsp_draft.
*        get parameter id 'ABAP_BSP_DSP' field data(bsp_dsp).
*        if bsp_dsp is initial.
*          data(hdlr_bsp) = new CL_ABAP_BEHV_HANDLER_MNGD_BSP( ).
*          hdlr_bsp->m_root = hsig-root.
*          set_managed_kind hdlr_bsp handler_idx.
*          hdlr_gen = hdlr_bsp.
*        else.
          data(hdlr_bsp_dsp) = new CL_ABAP_BEHV_HANDLER_MNGD_DSP( ).
          hdlr_bsp_dsp->m_root = hsig-root.
          set_managed_kind hdlr_bsp_dsp handler_idx.
          hdlr_gen = hdlr_bsp_dsp.
*        endif.

      when mki-csp_draft.
        data(hdlr_dsp) = new CL_ABAP_BEHV_HANDLER_MNGD_DSP( ).
        hdlr_dsp->m_root = hsig-root.
        set_managed_kind hdlr_dsp handler_idx.
        hdlr_gen = hdlr_dsp.

      when mki-dvm_active or mki-dvm_draft.
        data(hdlr_dvm) = new CL_ABAP_BEHV_HANDLER_MNGD_DVM( ).
        hdlr_dvm->m_root = hsig-root.
        set_managed_kind hdlr_dvm handler_idx.
        hdlr_gen = hdlr_dvm.

      when mki-bsp_active.
        data(hdlr_asp) = new CL_ABAP_BEHV_HANDLER_MNGD_BSP( ).
        hdlr_asp->m_root = hsig-root.
        set_managed_kind hdlr_asp handler_idx.
        hdlr_gen = hdlr_asp.

      when mki-missing.
        hdlr_gen = new CL_ABAP_BEHV_MISSING_HANDLER(
          clsname = hsig-clsname op = hsig-kind root = hsig-root )."where is  real entity?

      when others. " mki-csp_active
        data(hdlr_csp) = new CL_ABAP_BEHV_HANDLER_MNGD_CSP( ).
        hdlr_csp->m_root = hsig-root.
        set_managed_kind hdlr_csp handler_idx.
        hdlr_gen = hdlr_csp.

    endcase.

    hdlr-handler = hdlr_gen.

  else.
    " --- Create handler object (kernel method)
    do 2 times.
      instantiate_handler( exporting pool_name    = hsig-clsname
                                     hdlclss_idx  = handler_idx
                           importing handler      = hdlr-handler ).
      if hdlr-handler is not initial.
        exit.
      endif.
      " 2nd iteration if class constructor was called
    enddo.
  endif.

  if hdlr-handler is initial.
    return.  " this is an error
  endif.

  " --- Fill handler attributes and insert in singleton cache
  hdlr-handler->kind = hsig-kind.
  hdlr-handler->meth = hsig-hdlmeth_idx.
  hdlr-handler->pcnt = hsig-hdlparm_cnt.
  if busy is initial.
    insert value #( kind     = hsig-kind
                    clsname  = <clsname>
                    lclsidx  = hsig-handler_idx " NOT: handler_idx
                    methidx  = hsig-hdlmeth_idx
                    instance = hdlr-handler ) into table hdlr_instances.
  endif.

endif.

if hdlr_proj is not initial.
  " --- Prepare PROJECTION handler for job
  constants proj_is_draft type abp_behv_flag value '01'.

  if hsig-kind = 'M'.
    saver = cast #( value #( savr_instances[ clsname = <clsname>
                                             lclsidx = handler_idx ]-instance optional ) ).
* Savers are always created first, so creation here should not be necessary!
    if saver is initial.
      data(savr) = value t_saver( root = hsig-root pool_name = <clsname> saver_idx = handler_idx ). "?
    endif.

* (AUGM_in_PRCH): Proj 'M'odify possibly re-uses augment info from preceding 'P'recheck handler run
    hdlr_proj_prec ?= value #( hdlr_instances[ kind = 'P' clsname = hsig-root lclsidx = hsig-handler_idx methidx = 0 ]-instance optional ).
  endif.

* (AUGM_in_PRCH): delay PREPARE until immediately before call in CALL_PRECHECKERS
  if hsig-kind <> 'P'.
    " --- Find BASE handler (this may add entries to proj_job->unhandled_activities)
    hdlr_proj->prepare(
      job      = job
      kind     = hsig-kind
      saver    = saver  " if bound, base savers may be added
      preceding_handler = hdlr_proj_prec  " preceding Precheck for Modify
    ).
  endif.

endif.

endmethod.


method GET_HANDLERS.

data hdlr_sigs       type tt_hdlr_sig.
data trig_hdlrs      type tt_trigger_handler.
data trig_lock_hdlrs type tt_trigger_handler.

* The once intended possibility to retrieve HANDLERS and LOCK_HANDLERS
* simultaneously has not been used -- assert that it never will be:
assert handlers is supplied equiv lock_handlers is not supplied.


* Handler determination algorithm:
*
* 1. Determine all root entities for entities in changes
* 2. Load behavior from "BDI" load for all roots
* 3. Build handler list from changes list with up-to-date D010BEHV info
*    With sub-sequence detection; see algorithm description below.
* 4. If ordering information is present: Sort handler list
*
* Sub-sequence detection algorithm:
*
* The order of the changes list is the primary criterion for the order of handlers.
* (Goal: Support some "execution order control" by the caller.)
* - For each entry (the "lead change") in the changes list:
* -- For each handler having a trigger matching the change:
* --- Build a handler entry in the result list.
* --- For each parameter of the handler:
* ---- Find matching change entry, starting at the lead change, and bind it to the handler.
* In this algorithm, each handler would be allowed to occur in the result list at most once.
* This is generalized by the following rule:
* If a trigger entry occurs repeatedly in the changes list, this is considered the start of
* a new sub-sequence of changes. The above algorithm starts anew; all handlers can be used again.


clear handlers.
clear lock_handlers.
clear savers.
clear error_pools.

if job is initial or job->activities is initial.
  return.
endif.

" === Determine triggers and retrieve behavior for all activities in job
job->close( exporting all_root_entities = all_root_entities
                      kind              = kind
                      mock_instances    = mock_instances
                      hdlr_restriction  = hdlr_restriction
            importing order_behavior    = data(behv_order) ).

if lock_handlers is supplied.
  xtrace_triggers_gen job 'GET_HANDLERS' lock_triggers `L`.
else.
  xtrace_triggers_gen job 'GET_HANDLERS' triggers kind.
endif.

" === Build 'method signatures' for all relevant handlers; map triggers to handlers (by index)
if lock_handlers is supplied.
  GROUP_BEHV_BY_CLSS( exporting job                   = job
                                collect_savers        = 'X'  " for CLEANUP registration
                      importing handler_sigs          = hdlr_sigs
                                trigger_lock_handlers = trig_lock_hdlrs
                      changing  error_pools           = error_pools ).
else.
  GROUP_BEHV_BY_CLSS( exporting job                   = job
                                collect_savers        = 'X'  " for full SAVE registration
                      importing handler_sigs          = hdlr_sigs
                                SAVERS                = savers
                                trigger_handlers      = trig_hdlrs
                      changing  error_pools           = error_pools ).
endif.

if handlers is supplied.
  " --- get MOFIFY handlers
  GET_HANDLERS_IN_ACTV_ORDER( exporting job         = job
                                        actv_trigs  = job->actv_trigs
                                        trig_hdlrs  = trig_hdlrs
                              importing handlers    = handlers
                              changing  hdlr_sigs   = hdlr_sigs
                                        unhandled   = job->unhandled_activities
                                        error_pools = error_pools ).
  xtrace_handlers handlers.
endif.

if lock_handlers is supplied.
  " --- get LOCK handlers
  GET_HANDLERS_IN_ACTV_ORDER( exporting job         = job
                                        actv_trigs  = job->actv_lock_trigs
                                        trig_hdlrs  = trig_lock_hdlrs
                              importing handlers    = lock_handlers
                              changing  hdlr_sigs   = hdlr_sigs
                                        unhandled   = job->unhandled_activities_lock
                                        error_pools = error_pools ).
  xtrace_handlers lock_handlers.
endif.

dump_on_error_pools err.


if behv_order is initial.
  return.  " === No ordering information: done
endif.
if ignore_ordering is not initial or handlers is initial.
  return.
endif.
if lines( hdlr_sigs ) < 2.
  return.
endif.


data sorted_handlers like handlers.
data d010behos type tt_beho.
data d010beho type t_beho.
field-symbols <beho> type t_beho.

loop at behv_order assigning field-symbol(<behv>).
  d010beho = corresponding #( <behv> mapping handler_idx = ic
                                             order_idx   = im ).
  insert d010beho into table d010behos.
endloop.

" === Check if cross-pool ordering exists w.r.t. current job [and restriction]
data(cross_a) = filter #( d010behos where kind = 'A' ).
data(cross_b) = filter #( d010behos where kind = 'B' ).
if hdlr_restriction is not initial.
  loop at cross_a assigning <beho>.
    if not line_exists( hdlr_restriction[ name = <beho>-op_info ] ) ##WARN_OK.
      delete cross_a.  " eliminate cross-edge outside restriction
    endif.
  endloop.
  loop at cross_b assigning <beho>.
    if not line_exists( hdlr_restriction[ name = <beho>-op_info ] ) ##WARN_OK.
      delete cross_b.  " eliminate cross-edge outside restriction
    endif.
  endloop.
endif.


" === If no cross-pool dependencies exist: Use order-index values from D010BEHV
if cross_a is initial and cross_b is initial.

  types:
    begin of t_pool_hdlr_sort,
           hdlr_line type i,
           pool_name type t_pool_name,
           order_idx type i,
         end of t_pool_hdlr_sort .
  data pool_hdlr_sort type standard table of t_pool_hdlr_sort with empty key.
  loop at handlers assigning field-symbol(<hdlr>).
    append value #( hdlr_line = sy-tabix pool_name = <hdlr>-pool_name
                    order_idx = value #(
                      d010behos[ kind        = 'i'
                                 clsname     = <hdlr>-pool_name
                                 handler_idx = <hdlr>-handler_idx
                               ]-order_idx default 2147483647 )
                  ) to pool_hdlr_sort ##WARN_OK.
  endloop.
  " Sort: Alphabetically by pool-name, then by compiler-computed order index
  sort pool_hdlr_sort by pool_name order_idx.
  " Rebuild handler table, sorted by compiler-computed order index
  loop at pool_hdlr_sort assigning field-symbol(<hs>).
    assign handlers[ <hs>-hdlr_line ] to <hdlr>.
    append <hdlr> to sorted_handlers.
  endloop.
  handlers = sorted_handlers.
  return. " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

endif.


" === Cross-pool dependencies exist

" Note (*SORT*): With HDLR_SIGS being SORTED by CLSNAME, the INDEX (in POOLS) becomes
"                the position of the pool NAME in alphabetical order. Hence, the pool
"                name is not needed in VERTICES for the sort-by-name.
"
" Here, an explicit SORT on HDLR_SIGS is not even necessary, because it was built from
" a BEHAVIOR table that was sorted by CLSNAME.
"
"  SORT hdlr_sigs stable by clsname.
"  clear trig_hdlrs. " invalid after sort (and not used)

" 'A' and 'B' indicate order between pools and specific handlers
" 'b' indicates local order
" 'i' (precomputed local order) can be used only for pools that have no 'A'/'B' edges
"     for pools with 'A'/'B' edges, 'b' entries must be used again for topo-sort

  data(local_b) = filter #( d010behos where kind = 'b' ).  " [b]efore handler (local)
  data(local_i) = filter #( d010behos where kind = 'i' ).  " [i]ndex of handler in pool

  types: begin of t_hdlr_name_idx,
           name type string,
           hdlr type i,
         end of t_hdlr_name_idx.
  types: begin of t_pool,
           name       type t_pool_name,
           idx        type i,
           hdlrs      type sorted table of i with unique key table_line,
           hdlr_names type hashed table of t_hdlr_name_idx with unique key name,
         end of t_pool.
  types: begin of t_successor,
           pool type i,
           hdlr type i,
         end of t_successor.
  types: begin of t_vertex,
           pool type i,
           hdlr type i,
           rank type i,
          "name type t_pool_name,  " (*SORT*)
           succ type sorted table of t_successor with non-unique key pool hdlr,
         end of t_vertex.
  types: begin of t_ord_vertex,
           pool type i,
           hdlr type i,
           rank type i,
          "name type t_pool_name,  " (*SORT*)
         end of t_ord_vertex.
  types: begin of t_hdlr_posn,
           hdlr_line type i,
           order_idx type i,
         end of t_hdlr_posn.

  data pools    type hashed table of t_pool with unique key name.
  data pool     type t_pool.
  data hdlr_idx type i.
  data vertices type sorted table of t_vertex with unique key pool hdlr.
  data ord_vtcs type standard table of t_ord_vertex with empty key.
  data ord_vtx  like line of ord_vtcs.
  field-symbols: <pool1> type t_pool, <pool2> type t_pool.
  field-symbols <v> type t_vertex.

  define get_pool_idx.
    pool-name = &1.   assign pools[ name = pool-name ] to &2.
    if sy-subrc = 0.  pool-idx = &2-idx.
    else.             pool-idx = lines( pools ) + 1. insert pool into table pools assigning &2.  endif.
  end-of-definition.

  " (i) Collect pools and handlers which occur (!) in the current request
  loop at hdlr_sigs assigning field-symbol(<hsig>).
    if <hsig>-kind <> 'M'.
      continue.  " [L]ock handler, ignore
    endif.
    get_pool_idx <hsig>-clsname <pool1>.  " (*SORT*)
    insert <hsig>-handler_idx into table <pool1>-hdlrs.
    insert value #( pool = <pool1>-idx hdlr = <hsig>-handler_idx "name = <hsig>-clsname )
                  ) into table vertices.
    if sy-subrc = 0 and local_b is not initial.
      " store map: (handler name -> handler index) for local part of topological sort
      loop at local_i assigning <beho> where kind = 'i' and clsname = <hsig>-clsname.
        insert value #( name = <beho>-handlername hdlr = <beho>-handler_idx )
         into table <pool1>-hdlr_names.
      endloop.
    endif.
  endloop.

  " (ii) Build dependency graph from cross-pool ordering, normalized on "Before" direction
  " (ii-a) '[B]efore' edges
  loop at cross_b assigning <beho>.
    get_pool_idx <beho>-clsname <pool1>.
    assign vertices[ pool = <pool1>-idx hdlr = <beho>-handler_idx ] to <v>.
    if sy-subrc <> 0.
      continue.  " (source handler not in request -- impossible due to selection)
    endif.
    get_pool_idx <beho>-op_info <pool2>.
    if sy-subrc <> 0.
      continue.  " (target pool not in request -- possible)
    endif.
    loop at <pool2>-hdlrs into hdlr_idx.
      insert value #( pool = <pool2>-idx hdlr = hdlr_idx ) into table <v>-succ.
    endloop.
  endloop.
  " (ii-b) '[A]fter' edges
  loop at cross_a assigning <beho>.
    get_pool_idx <beho>-op_info <pool1>.
    if sy-subrc <> 0.
      continue.  " (source pool not in request -- possible)
    endif.
    get_pool_idx <beho>-clsname <pool2>.
    if sy-subrc <> 0.
      continue.  " (target pool not in request -- impossible due to selection)
    endif.
    if not line_exists( vertices[ pool = <pool2>-idx hdlr = <beho>-handler_idx ] ).  " alternative: if not line_exists( <pool2>-hdlrs[ table_line = <beho>-handler_idx ] ).
      continue.  " handler not in request
    endif.
    loop at <pool1>-hdlrs into hdlr_idx.
      assign vertices[ pool = <pool1>-idx hdlr = hdlr_idx ] to <v>.
      if sy-subrc = 0.
        insert value #( pool = <pool2>-idx hdlr = <beho>-handler_idx ) into table <v>-succ.
      endif.
    endloop.
  endloop.

  " (iii) Add dependencies from pool-local ordering
  loop at local_b assigning <beho>.
    get_pool_idx <beho>-clsname <pool1>.
    assign vertices[ pool = <pool1>-idx hdlr = <beho>-handler_idx ] to <v>.
    if sy-subrc <> 0.
      continue.  " else (source handler not in request -- impossible due to selection)
    endif.
    hdlr_idx = value #( <pool1>-hdlr_names[ name = <beho>-op_info ]-hdlr default -1 ).
    if hdlr_idx <> -1 and line_exists( vertices[ pool = <pool1>-idx hdlr = hdlr_idx ] ).
      insert value #( pool = <pool1>-idx hdlr = hdlr_idx ) into table <v>-succ.
    " else (target handler not in request -- possible)
    endif.
  endloop.

  " (iv) Topological sort: assign rank (#succcessors)
  data(rank) = -1.
  do.
    data(cnt) = lines( ord_vtcs ).
    loop at vertices assigning <v> where rank is initial and succ is initial.
      <v>-rank = rank.
      move-corresponding <v> to ord_vtx.  append ord_vtx to ord_vtcs.
    endloop.
    if cnt = lines( ord_vtcs ).
      exit.  " no more unranked successor-less vertex found
    endif.
    loop at ord_vtcs from cnt + 1 assigning field-symbol(<ov>).
      loop at vertices assigning field-symbol(<vs>) where succ is not initial.
        loop at <vs>-succ transporting no fields where pool = <ov>-pool and hdlr = <ov>-hdlr.
          delete <vs>-succ.  exit.
        endloop.
      endloop.
    endloop.
    add -1 to rank.
  enddo.

  if lines( ord_vtcs ) <> lines( vertices ).
    " --- Error: Circular ordering detected
    loop at vertices assigning <v> where succ is not initial.
      assign pools[ idx = <v>-pool ] to <pool1>.  "#EC CI_HASHSEQ
      data(hname) = |{ <pool1>-name }|. ":{ <pool1>-hdlr_names[ hdlr = <v>-hdlr ]-name }|.
      raise shortdump type cx_abap_behv_runtime_error
        message e022 with hname
        exporting "textid    = cx_abap_behv_runtime_error=>circular_ordering
                  handler = hname.
    endloop.
  endif.

  " (v-a) Sort vertices by rank, pool-name/-index (*SORT*), handler-index
  sort ord_vtcs by rank pool hdlr.  " rank name hdlr.
  " (v-b) Set final sort-index
  loop at ord_vtcs assigning field-symbol(<ord_vtx>).
    <ord_vtx>-rank = sy-tabix.
  endloop.
  " (v-c) Copy to sorted table for quick lookup by (pool-name, hdlr-index)
  data sortidx_lookup type sorted table of t_ord_vertex with non-unique key pool hdlr. " name hdlr.
  sortidx_lookup = ord_vtcs.

  " (vi) Assign sort-index to handlers
  data hdlr_posn type standard table of t_hdlr_posn with empty key.
  loop at handlers assigning <hdlr>.
    hdlr_idx = sy-tabix.
    get_pool_idx <hdlr>-pool_name <pool1>.
    append value #( hdlr_line = hdlr_idx
      order_idx = value #( sortidx_lookup[ pool = <pool1>-idx  "name = <hdlr>-pool_name
                                           hdlr = <hdlr>-handler_idx
                                         ]-rank default 2147483647 )
    ) to hdlr_posn.
  endloop.
  sort hdlr_posn by order_idx hdlr_line.
  " Rebuild handler table
  loop at hdlr_posn assigning field-symbol(<hp>).
    assign handlers[ <hp>-hdlr_line ] to <hdlr>.
    append <hdlr> to sorted_handlers.
  endloop.
  handlers = sorted_handlers.

endmethod.


method GET_HANDLERS_IN_ACTV_ORDER.

* This algorithm produces a list of handlers whose order is strictly driven by the order of
* the activities list.
* So it can be used if "execution order control" by the caller is intended.
* Handler-ordering information (BEFORE/AFTER clauses) is completely ignored.

* Algorithm with sub-sequence detection:
* - For each entry (the "lead activity") in the activities list:
* -- For each handler having a trigger matching the activity:
* --- Build a handler entry in the result list.
* --- For each parameter of the handler:
* ---- Find matching activity entry, starting at the lead activity, and bind it to the handler.
* In this algorithm, each handler would be allowed to occur in the result list at most once.
* This is generalized by the following rule:
* If a trigger entry occurs repeatedly in the activities list, this is considered the start of
* a new sub-sequence of activities. The above algorithm starts anew; all handlers can be used again.


field-symbols <th>   type t_trigger_handler.
field-symbols <hdlr> like line of handlers.
field-symbols <hsig> like line of hdlr_sigs.
data param           type t_handler_param.
data trigs_in_sub    type xstring.  " bits ~ triggers used in current sub-sequence
data trigs_zero      type xstring.  " zero-bits of suitable length

data act_bdef_id type i value -99.
data chk_bdef_id type i.
data act_root_name type abp_root_entity_name.

clear handlers.

if actv_trigs is initial.
  return.
endif.

trigs_zero   = repeat( val = `00` occ = lines( job->triggers ) / 8 + 1 ).
trigs_in_sub = trigs_zero.

" --- Determine sub-sequences in activities (defined by repeated trigger)
data subseqs type standard table of i with empty key.
data(seq_len) = 0.
loop at actv_trigs into data(actv_trig).
  if actv_trig = 0.
    " Illegal activity (e.g. operation 'A' with READ action)
    append sy-tabix to unhandled.
  else.
    if bit-set( actv_trig ) bit-and trigs_in_sub <> trigs_zero.
      unassign <th>.
      assign trig_hdlrs[ actv_trig_idx = actv_trig ] to <th>.
      if <th> is assigned.
        assign hdlr_sigs[ <th>-hdlr_idx ] to <hsig>.
        if <hsig>-clsname(1) = '%'.  " %MANAGED
          " No sub-sequence division for MANAGED handler
        else.
          unassign <th>.
        endif.
      endif.
      if <th> is not assigned.
        " Repeated trigger; sequence ends
        append seq_len to subseqs.
        trigs_in_sub = trigs_zero.
        seq_len = 0.
      endif.
    endif.
    set bit actv_trig of trigs_in_sub to 1.
  endif.
  add 1 to seq_len.
endloop.
append seq_len to subseqs.  " final sub-sequence


" --- Process all activities, partitioned by sub-sequences
data(subseq_beg) = 1.
loop at subseqs into seq_len.
  data(subseq_end) = subseq_beg + seq_len - 1.

  " --- Process all activities in current sub-sequence
  loop at actv_trigs from subseq_beg to subseq_end into actv_trig.

    check actv_trig <> 0.
    data(activity_idx) = sy-tabix.

    " --- Find usable handlers for current activity
    loop at trig_hdlrs assigning <th> where actv_trig_idx = actv_trig.

      assign hdlr_sigs[ <th>-hdlr_idx ] to <hsig>.
      if <hsig>-kind = '@'.
        continue.  " pool has been found erroneous
      endif.

      if <hsig>-hlist_idx is not initial.
        " --- Handler already in result set (for previous activity of sub-sequence)
        assign handlers[ <hsig>-hlist_idx ] to <hdlr>.
      else.
        " --- Insert new handler in result list
        append value #( pool_name    = <hsig>-clsname
                        handler_idx  = <hsig>-handler_idx
                        root         = <hsig>-root
                      ) to handlers assigning <hdlr>.
        <hsig>-hlist_idx = lines( handlers ).
        " --- Create handler object
        " (for PROJECTION, this may add entries to job->unhandled_activities)
        get_handler( exporting job  = job
                               hsig = <hsig>
                     changing  hdlr = <hdlr> ).
        if <hdlr>-handler is initial.
          " Handler could not be instantiated (pool has syntax error)
          data(error_pool_name) = <hsig>-clsname.
          delete handlers where pool_name = error_pool_name.
          insert error_pool_name into table error_pools.
          loop at hdlr_sigs assigning field-symbol(<err_hsig>) where clsname = error_pool_name.
            <err_hsig>-kind = '@'.  " mark erroneous
          endloop.
          continue.
        endif.
      endif.

      " --- Bind activity to parameter of handler
      loop at <hsig>-params using key actv assigning field-symbol(<hpar>)
       where actv_trig_idx = actv_trig.
        assign job->activities[ activity_idx ] to field-symbol(<actv>).
        move-corresponding <actv> to param.
        param-actv_idx   = activity_idx.
        param-param_idx  = <hpar>-param_idx.
        param-result_idx = <hpar>-result_idx.
        if <actv>-op = op-validate.
          <hdlr>-context-entity_name = <actv>-entity_name.
          <hdlr>-context-sub_name    = <actv>-sub_name.

        elseif <actv>-op ca op_chars_w_grp.

          if job->M_IN_LOCAL_MODE is not initial or
           ( cl_abap_behv_job_base=>CURR_EML_JOB is not initial and
             cl_abap_behv_job_base=>CURR_EML_JOB->M_IN_LOCAL_MODE is not initial ).
            " An AUTH/FEATURES call despite LOCAL MODE -- due to EXTENSIBLE:
            " Filter out handlers with the same BDEF-id as the running handler
            if act_bdef_id = -99.
              call 'BEHV_EXEC' id 'OP' field 10 id 'BDEF_ID' field act_bdef_id id 'ROOT_NAME' field act_root_name.  "#EC CI_CCALL
            endif.
            if act_bdef_id >= 0 and act_root_name = <hsig>-root.
              call 'BEHV_EXEC' id 'OP' field 11 id 'OBJ' field <hdlr>-handler id 'BDEF_ID' field chk_bdef_id.  "#EC CI_CCALL
              if chk_bdef_id = act_bdef_id.
                clear <hdlr>-params.
                exit.  " handler will be discarded below
              endif.
            endif.
          endif.

          if <hpar>-name is not initial.
            " --- reduce full FEATURES/AUTHORIZATION request/result structure to GROUP
            CL_ABAP_BEHVDESCR=>create_data( exporting p_name     = <actv>-entity_name
                                                      p_op       = <actv>-op
                                                      p_root     = <hsig>-root
                                                      p_sub_name = <hpar>-name
                                                      p_kind     = if_abap_behv=>typekind-REQUEST
                                            receiving p_data     = param-links ).
            assign param-links->*  to field-symbol(<igrp_req>).
            assign <actv>-links->* to field-symbol(<full_req>).
            move-corresponding <full_req> to <igrp_req>.
            if <igrp_req> is initial.
              " the GROUP is not covered by the request
              continue.  " discard this param (if no other param gets bound, handler is removed below)
            endif.
            CL_ABAP_BEHVDESCR=>create_data( exporting p_name     = <actv>-entity_name
                                                      p_op       = <actv>-op
                                                      p_root     = <hsig>-root
                                                      p_sub_name = <hpar>-name
                                                      p_kind     = if_abap_behv=>typekind-RESULT
                                            receiving p_data     = param-results ).
          endif.

          " in case of projection it is more useful to look at base activity
          "  The base activity can be empty even if the test above succeeds
          "  because some of the fields are handled locally by the projection handler
          "  currently only instance features
          if <actv>-op CA 'IGaJ' and <hsig>-handler_idx in mki_proj.
           data p_hdlr type ref to cl_abap_behv_handler_proj.
           p_hdlr ?= <hdlr>-handler.
           if p_hdlr->has_active_request( activity_idx ) is  initial.
             continue. " discard this parameter (if no other parameter gets bound, handler is removed below)
           endif.
          endif. "projection

        endif. "<actv>-op ca op_chars_w_grp
        append param to <hdlr>-params.
      endloop. " at <hsig>-params for parameters of handler <hsig>

      if <hdlr>-params is initial.
        if <hsig>-hlist_idx = lines( handlers ).
          delete handlers index <hsig>-hlist_idx.  " due to empty-request removal above
          clear <hsig>-hlist_idx.
        else.
          continue.  " should never be here (previous successfully bound param[s] exist)
        endif.
      endif.

    endloop. " at trig_hdlrs where actv_trig_idx = actv_trig

    if sy-subrc = 4.
      " --- No handler for this activity
      append activity_idx to unhandled.
    endif.

  endloop. " at actv_trigs from subseq_beg to subseq_end

  if subseq_end < lines( actv_trigs ).
    subseq_beg = subseq_end + 1.
  endif.

  " Re-enable all handlers for the next sub-sequence / for retrieval of FEATURE-CHECK or LOCK handlers
  loop at hdlr_sigs assigning <hsig>.  clear <hsig>-hlist_idx.  endloop.

endloop. " at subseqs

if kind <> 'P' and line_exists( handlers[ handler_idx = mki-csp_draft ] ).

  split_dsp_handler( exporting job      = job
                     changing  handlers = handlers ).

endif.

endmethod.


method GET_IMPLEMENTATIONS_KRN by kernel module ab_km_behv_get_impls.
endmethod .


method GET_SAVER.

field-symbols <clsname> type c.

define set_meth.
  if &2-&3 <> not_implemented.
    &1-&3 = &2-&3.
  endif.
end-of-definition.

data(is_managed) = xsdbool( savr-saver_idx <= 0 ). " %MANAGED

" --- Determine key (part) CLSNAME for singleton cache
if is_managed is initial.
  assign savr-pool_name to <clsname>.  " unmanaged: singleton per handler class
else.
  assign savr-root      to <clsname>.  " managed: singleton per root
endif.

data all_finalize_repeatable type c length 1.
get parameter id 'ABAP_BEHV_REFINALIZE' field all_finalize_repeatable.
if all_finalize_repeatable is not initial
    or savr-root = 'VER52380_C' or savr-root = 'VER52380_B'. "TODO (as soon as "repeatable FINALIZE" is load property: CL_ABAP_BEHV_LOAD=>GET_LOAD()
  savr-finalize_multi = 'X'.
endif.

" --- Try singleton cache
assign savr_instances[ clsname = <clsname>
                       lclsidx = savr-saver_idx ]
  to field-symbol(<inst>).

if sy-subrc = 0.

  savr-saver = <inst>-instance.
  " method set may vary (draft/active) => take 'maximum'
  set_meth meth savr-saver->meth finalize.
  set_meth meth savr-saver->meth check_before_save.
  set_meth meth savr-saver->meth adjust_numbers.
  set_meth meth savr-saver->meth save.
  set_meth meth savr-saver->meth cleanup.
  set_meth meth savr-saver->meth cleanup_finalize.
  set_meth meth savr-saver->meth save_modified.
  set_meth meth savr-saver->meth map_messages.
  savr-saver->meth = meth.

else.

  if is_managed is not initial.  " %MANAGED, %MOCKED
    if  savr-saver_idx = mki-projection.
      data(savr_proj) = CL_ABAP_BEHV_SAVER_PROJ=>create( root = savr-root
                                                         job  = job ).
      savr-saver = savr_proj.
    elseif savr-saver_idx = mki-mocked.
      data(savr_mock) = CL_ABAP_BEHV_SAVER_MOCK=>create( object = mock_instances[ root_name = savr-root ]-object ).
      savr-saver = savr_mock.
    else.
      data savr_mngd type ref to CL_ABAP_BEHV_SAVER_MANAGED.
      if savr-saver_idx = mki-csp_draft.
        savr_mngd = new CL_ABAP_BEHV_SAVER_MNGD_DSP( ).
      elseif savr-saver_idx = mki-bsp_draft.
*        get parameter id 'ABAP_BSP_DSP' field data(bsp_dsp).
*        if bsp_dsp is not initial.
          savr_mngd = new CL_ABAP_BEHV_SAVER_MNGD_DSP( ).
*        else.
*          savr_mngd = new CL_ABAP_BEHV_SAVER_MNGD_BSP( ).
*        endif.
      elseif savr-saver_idx = mki-bsp_active.
        savr_mngd = new CL_ABAP_BEHV_SAVER_MNGD_BSP( ).
      elseif savr-saver_idx = mki-dvm_active.
        savr_mngd = new CL_ABAP_BEHV_SAVER_DVM( ).
      else.
        savr_mngd = new CL_ABAP_BEHV_SAVER_MNGD_CSP( ).
      endif.
      savr_mngd->m_root = savr-root.
      set_managed_kind savr_mngd savr-saver_idx.
      savr-saver = savr_mngd.
    endif.
  else.
    " --- Create handler object (kernel method)
    do 2 times.
      instantiate_saver( exporting pool_name   = savr-pool_name
                                   savclss_idx = savr-saver_idx
                         importing saver       = savr-saver ).
      if savr-saver is not initial.
        exit.
      endif.
      " 2nd iteration if class constructor was called
    enddo.
  endif.
  if savr-saver is initial.
    return.  " this is an error
  endif.

  savr-saver->meth = meth.
  insert value #( clsname  = <clsname>
                  lclsidx  = savr-saver_idx
                  instance = savr-saver ) into table savr_instances.

endif.

endmethod.


method GET_SAVER_RESPONSE.

clear: failed, mapped, reported.

if saver_collector is initial or saver_collector->savers_response is initial.
  return.
endif.

assign saver_collector->savers_response[ saver = saver ] to field-symbol(<savres>).
if sy-subrc <> 0.
  return.
endif.

if <savres>-phase <> phase.
  " stored response is outdated (wrong phase) -> remove
  clear: <savres>-failed, <savres>-mapped, <savres>-reported.
  <savres>-phase = phase.
  "delete table saver_collector->savers_response from <savres>.
  return.  " not found
endif.

failed   = <savres>-failed.
mapped   = <savres>-mapped.
reported = <savres>-reported.

found = 'X'.

endmethod.


method GROUP_BEHV_BY_CLSS.

types: begin of t_adh,
         hdlr_idx   type i,
         actv_idx_1 type i,
         actv_idx_2 type i,
       end of t_adh.

define set_behv_is_draft.  " same as in CL_ABAP_BEHV_JOB_BASE
  &2 = cond #( when &1-ic in mki_draft then if_abap_behv=>mk-on ).
end-of-definition.

data adh_sigs type standard table of t_adh with empty key.
data handlers_uniq type hashed table of t_trigger_handler with unique key table_line.
data is_draft type CL_ABAP_BEHV_JOB_BASE=>T_IS_DRAFT.
data meth like c_meth_none.
data saver type t_saver.
data n_bsp_sav type i.
data n_csp_sav type i.
data dvm_savers type tt_saver.
data acc_modify  type c length 1.
data acc_direct  type c length 1.
data with_savers type c length 1.
field-symbols <midx> type i.
field-symbols <saver> type t_saver.

clear handler_sigs.
clear trigger_handlers.
clear trigger_lock_handlers.
clear savers.

if collect_savers is not initial.
  acc_modify = xsdbool(
    job->m_level = cl_abap_behv_job_base=>modify_direct or
    job->m_level = cl_abap_behv_job_base=>modify_base ).
  acc_direct = xsdbool(
    job->m_level = cl_abap_behv_job_base=>modify_direct or
    job->m_level = cl_abap_behv_job_base=>read_direct ).
  with_savers = xsdbool(
    acc_modify is not initial or
    acc_direct is not initial or
    job->m_level = cl_abap_behv_job_base=>read_base ).
endif.

" === Group D010BEHV entries into handlers/savers; map triggers to handlers

data(special_ops) =
  d010behv_op-pseudo-save &&
  d010behv_op-real-lock &&
  d010behv_op-real-lock_edit &&
  cond #( when job->m_level <> cl_abap_behv_job_base=>modify_augm then op_chars_augmenting ).

loop at job->behavior assigning field-symbol(<behv>) group by
 ( clsname    = <behv>-clsname
   handleridx = "<behv>-ic
    cond #(
     when <behv>-operation = d010behv_op-pseudo-save
      and ( <behv>-ic in mki_proj_draft )
      then mki-projection else <behv>-ic )  " unify IC of projection-savers
   hdlmethidx = cond #(
     when <behv>-operation na special_ops then <behv>-im  " handler method (vtabId)
     " (-1) separates SAVE from Interaction:
     when <behv>-operation = d010behv_op-pseudo-save        then -1
     " (-2) separates %MANAGED [L]ock from [M]odify:
     when ( <behv>-operation = d010behv_op-real-lock or
            <behv>-operation = d010behv_op-real-lock_edit )
      and <behv>-im = 0                                     then -2
     " (-3) filters out irrelevant operations (in the current execution phase):
     when <behv>-operation ca op_chars_augmenting           then -3
     else <behv>-im )  " handler method (vtabId)

   " ROOTNAME must be part of group key for %MANAGED to keep generic handlers for different BOs apart
   rootname = cond #( when <behv>-clsname(1) = '%' then <behv>-rootname )

 )
 assigning field-symbol(<behv_grp>).

  if <behv_grp>-hdlmethidx = -3.
    continue.  " irrelevant behavior for (current execution phase of) the job
  endif.
  if <behv_grp>-hdlmethidx = -1.
    " --- This is a SAVE behavior
    if with_savers is initial.
      continue.  " not a SAVE-relevant job
    endif.
    meth = c_meth_none.
    saver = value t_saver( pool_name  = <behv_grp>-clsname
                           saver_idx  = <behv_grp>-handleridx
                           acc_direct = acc_direct
                           acc_modify = acc_modify ).
    loop at group <behv_grp> assigning field-symbol(<savr>).
      if <behv_grp>-clsname(3) = '%MA'.  " %MANAGED
        meth = c_meth_managed.
      elseif <behv_grp>-clsname(3) = '%MO'.  " %MOCKED
        meth = c_meth_mocked.
      else.
        " assign e.g. meth-FINALIZE and set method index
        assign component <savr>-op_info of structure meth to <midx>.
        assert sy-subrc = 0.
        <midx> = <savr>-im.
      endif.
      if saver-root is initial.
        saver-root = <savr>-rootname.
      endif.
    endloop.
    " --- Savers are created immediately
    get_saver( exporting job = job
                         meth = meth
               changing  savr = saver ).
    if saver-saver is initial.
      insert saver-pool_name into table error_pools.
    else.
      if saver-saver_idx = mki-dvm_active.
        append saver to dvm_savers.
      else.
        append saver to savers.
        if     saver-saver_idx = mki-bsp_draft.
          add 1 to n_bsp_sav.
        elseif saver-saver_idx = mki-csp_active.
          add 1 to n_csp_sav.
        endif.
      endif.
    endif.
    continue.
  endif.  " SAVE behavior

  append value #( clsname     = <behv_grp>-clsname
                  handler_idx = <behv_grp>-handleridx
                  hdlmeth_idx = <behv_grp>-hdlmethidx )
   to handler_sigs
   assigning field-symbol(<hsig>).

  data(trig_hdlr) = value t_trigger_handler( hdlr_idx = lines( handler_sigs ) ).

  loop at group <behv_grp> assigning field-symbol(<hdlr>).
    " --- Store only the "trigger index according to current activities"
    set_behv_is_draft <hdlr> is_draft.
    " Note: <hdlr>-IA < 0 for C/U/D/R; <hdlr>-IA > 0 for actions/assocs
    if <hdlr>-ia <> idx_lock and <hdlr>-ia <> idx_lock_edit.
      data(behv_idx) = cond #(
       when <hdlr>-operation na op_chars_assoc or <hdlr>-ia >= 16384
       then <hdlr>-ia else <hdlr>-ia + 16384 ).  " put CBA/RBA beyond 0x4000 to distinguish from actions
      trig_hdlr-actv_trig_idx = line_index(
        job->triggers[ key primary_key components index = behv_idx entity = <hdlr>-entity
                                is_draft = is_draft ] ).
      if   is_draft = if_abap_behv=>mk-off
       and ( <hdlr>-ic = mki-mocked or
             ( <hdlr>-ic <> mki-projection  " there are specialized "PROJ-on-DRAFT" handlers
               and job->has_active_draft_handling(  " actual check if operation has ADH
                    entity = <hdlr>-entity
                    operation = <hdlr>-operation ) ) ).
        " op has ACTIVE/DRAFT handling; there may be 0..2 activities in the job for it
        is_draft = if_abap_behv=>mk-on.  " from OFF to ON
        data(other_actv_trig_idx) = line_index(
          job->triggers[ key primary_key components index = behv_idx entity = <hdlr>-entity
                                  is_draft = is_draft ] ).
        if trig_hdlr-actv_trig_idx = 0.
           " found no activity for ACTIVE, found activity for DRAFT
          trig_hdlr-actv_trig_idx = other_actv_trig_idx.
        elseif other_actv_trig_idx <> 0.
          " there is both an ACTIVE and a DRAFT activity: ACTIVE is processed here;
          " DRAFT will be cloned from ACTIVE in a final step below
          insert value #( hdlr_idx   = trig_hdlr-hdlr_idx
                          actv_idx_1 = trig_hdlr-actv_trig_idx
                          actv_idx_2 = other_actv_trig_idx )
           into table adh_sigs.
        endif.
      endif.
      if trig_hdlr-actv_trig_idx <> 0.
        insert trig_hdlr into table handlers_uniq.
        if sy-subrc  = 0.
          " Avoid duplicates, which might arise in very rare cases because:
          " (i)  The table key of TRIGGER_HANDLERS is only on ACTV_TRIG_IDX.
          " (ii) The same HDLR_IDX may appear twice for the same activity if there are
          "      implementation groups for FEATURES (i.e. handler handles >= 2 groups).
          " The key must remain partial to preserve handler-ordering-by-activity.
          insert trig_hdlr into table trigger_handlers.
        endif.
      endif.
    else. "if <hdlr>-kind = 'L'.
      trig_hdlr-actv_trig_idx = line_index(
        job->lock_triggers[ key primary_key components
                                 index    = <hdlr>-ia
                                 entity   = <hdlr>-entity
                                 is_draft = is_draft ] ).
      if trig_hdlr-actv_trig_idx = 0 and <hdlr>-ic = mki-mocked.
        " try Draft trigger (lock-for-edit); mock handles Active and Draft
        trig_hdlr-actv_trig_idx = line_index(
          job->lock_triggers[ key primary_key components
                                   index    = <hdlr>-ia
                                   entity   = <hdlr>-entity
                                   is_draft = if_abap_behv=>mk-on ] ).
      endif.
      if trig_hdlr-actv_trig_idx <> 0.
        insert trig_hdlr into table trigger_lock_handlers.
      endif.
    endif.

    insert value #( actv_trig_idx = trig_hdlr-actv_trig_idx " !
                    param_idx     = <hdlr>-ip
                    result_idx    = <hdlr>-ir
                    name          = <hdlr>-op_info
                  ) into table <hsig>-params.
  endloop.

  " identical values for all members of a group:
  <hsig>-root        = <hdlr>-rootname.
  <hsig>-hdlparm_cnt = <hdlr>-np. "<behv_grp>-parm_cnt.
  <hsig>-kind        = <hdlr>-kind.

  if <behv_grp>-hdlmethidx = -2.
    " mark %MANAGED [L]ock
    <hsig>-hdlmeth_idx = 0.
    <hsig>-kind = 'L'.
  endif.

endloop.


if adh_sigs is not initial.
  " === For Active/Draft handlers, clone their signature, exchanging only the activity index
  loop at adh_sigs assigning field-symbol(<adh_hdlr>) group by <adh_hdlr>-hdlr_idx.
    data(hdlr_sig) = handler_sigs[ <adh_hdlr>-hdlr_idx ].
    data(hdlr_idx) = lines( handler_sigs ) + 1.
    loop at hdlr_sig-params assigning field-symbol(<param>).
      loop at group <adh_hdlr> assigning field-symbol(<adh>).
        if <param>-actv_trig_idx = <adh>-actv_idx_1.
          <param>-actv_trig_idx = <adh>-actv_idx_2. " exchange activity index in cloned signature
          trig_hdlr = value #( actv_trig_idx = <adh>-actv_idx_2
                               hdlr_idx      = hdlr_idx ).
          insert trig_hdlr into table trigger_handlers.
        endif.
      endloop.
    endloop.
    insert hdlr_sig into table handler_sigs.
  endloop.
  if cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-default.
    types: begin of t_adh_trace,
             class  type string,
             entity type abp_entity_name,
             op     type abp_behv_op,
             sub    type abp_behv_activities-sub_name,
           end of t_adh_trace.
     types tt_adh_trace type standard table of t_adh_trace with empty key.
     cl_abap_behv_tracer=>tracer->trace(
     message   = |{ text_009 } ({ lines( adh_sigs ) })|
     procedure = 'GROUP_BEHV_BY_CLSS'
     content   = value tt_adh_trace( for <s> in adh_sigs let <h> = handler_sigs[ <s>-hdlr_idx ]
                                                             <t> = job->triggers[ <s>-actv_idx_1 ] in
       ( class = |{ <h>-clsname } [{ <h>-handler_idx }]| entity = <t>-entity op = <t>-operation sub = <t>-sub_name ) ) ).
  endif.
endif.


if savers is initial.
  return.
endif.


" === for CSP savers, collect associated unmanaged savers into M_SUB_SAVERS
" (PROJECTION works differently, because D010BEHV entries are for *distinct* entities)
if n_csp_sav is not initial and lines( savers ) > 1.
  data csp_saver type ref to CL_ABAP_BEHV_SAVER_MNGD_CSP.
  loop at savers assigning field-symbol(<rs>)
   group by ( ROOT = <rs>-root size = group size ) assigning field-symbol(<gs>).
    if <gs>-size < 2.
      continue.  " not a root with more than one saver
    endif.
    clear csp_saver.
    loop at group <gs> assigning field-symbol(<ms>).
      if <ms>-saver is instance of CL_ABAP_BEHV_SAVER_MNGD_CSP.
        csp_saver = cast #( <ms>-saver ).
        exit.
      endif.
    endloop.
    if csp_saver is not bound.
      continue.
    endif.
    loop at group <gs> assigning <ms>.
      if <ms>-saver_idx > 0. " and <ms>-saver is not instance of CL_ABAP_BEHV_SAVER_MNGD_CSP. " redundant
        insert corresponding #( <ms> ) into table csp_saver->m_sub_savers.
        clear <ms>-root.  " entry is removed from SAVERS below...
      endif.
    endloop.
  endloop.
  delete savers where root is initial.  " ...here
endif.  " CSP savers treatment

" === for BSP savers, add UNmanaged saver if job contains their ACTIVATE action
if n_bsp_sav is not initial.

  data act_entities type abp_entity_name_tab.
  data act_roots type cl_abap_behvdescr=>tt_entity_uniq.
  data bdi_ops type tt_d010behv.
  loop at job->entity_subs assigning field-symbol(<esub>)
   where op = op-action and sub = 'ACTIVATE' and adh-dft = 'X'.
    insert <esub>-entity into table act_entities.
  endloop.
  if act_entities is not initial.
    " --- there is a BSP saver and there is an ACTIVATE draft action in the job
    if lines( job->actv_roots ) = 1.
      act_roots = job->actv_roots.
    else.
      cl_abap_behvdescr=>get_roots_of_entities( exporting entities = act_entities
                                                changing  roots    = act_roots ).
    endif.
    loop at savers assigning <saver> where saver_idx = mki-bsp_draft.
      check line_exists( act_roots[ table_line = <saver>-root ] ).
      " --- get UNmanaged (i.e. ACTIVE) SAVE behavior for this BSP saver's root
      clear bdi_ops.
      CL_ABAP_BEHV_CTRL=>GET_IMPLEMENTATIONS_KRN(
        exporting root_entity = <saver>-root
                  kind_pos    = 'S'  " [S]ave operation only
                  kind_neg    = C_IMPL_REQ_DRAFT
        changing  impl_ops    = bdi_ops
      ).
      saver = value t_saver( root       = <saver>-root
                             acc_direct = acc_direct
                             acc_modify = acc_modify ).
      meth = c_meth_none.
      loop at bdi_ops assigning field-symbol(<bsav>).
        if saver-pool_name is initial.
          if line_exists( savers[ pool_name = <bsav>-clsname saver_idx = <bsav>-ic ] ).
            exit.  " saver already registered (by another operation)
          endif.
          saver-pool_name = <bsav>-clsname.  saver-saver_idx = <bsav>-ic.
        else.
          assert saver-pool_name = <bsav>-clsname and saver-saver_idx = <bsav>-ic.
        endif.
        if <bsav>-ic = mki-bsp_active.
          meth = c_meth_managed.
          exit.
        endif.
        assign component <bsav>-op_info of structure meth to <midx>.  assert sy-subrc = 0.
        <midx> = <bsav>-im.
      endloop.
      if meth = c_meth_none.
        continue.
      endif.
      get_saver( exporting job = job meth = meth changing savr = saver ).
      if saver-saver is not initial.
        append saver to savers.  " add corresponding UNmanaged saver
      endif.
    endloop.
  endif.

endif.  " BSP savers treatment


data(curr_proj) = cl_abap_behv_aux=>g_curr_context-from_projection.
if curr_proj is not initial and saver_collector is not initial
 and saver_collector->savers is not initial.
  data(rela) = cl_abap_behv_load=>get_relation( source_entity = curr_proj
                                                kind          = cl_abap_behv_load=>c_relation_base
                                                original_root = curr_proj ).
  loop at savers assigning field-symbol(<new_saver>)
   where saver_idx >= 0
     and root = rela->target_entity
     and saver->meth-ADJUST_NUMBERS <> cl_abap_behv_ctrl=>not_implemented
   .
  " If this is a non-generic or CSP-ACTIVE saver with ADJUST_NUMBERS and
  " a PROJ call is in the context [[and the PROJ has a DSP (i.e. draft) BASE saver]]:
  " Add this saver as a BASE saver to the PROJ saver.
  " This is necessary to lift (the MAPPED results of) ADJUST_NUMBERS to PROJ when a
  " Draft ACTIVATE is triggered from PROJ level.
  " (Note: JOB->m_from_projection isn't usually set here(?). But the context got the
  " info in CALL_HANDLER for ACTIVATE, which is in the call stack here.)
    loop at saver_collector->savers assigning field-symbol(<proj_saver>) using key kroo
     where root = curr_proj
       and saver_idx = mki-projection.
      data(proj_saver) = cast cl_abap_behv_saver_proj( <proj_saver>-saver ).
      insert <new_saver> into table proj_saver->m_base_savers.
      delete savers.
      exit.
    endloop.
  endloop.
endif.


if dvm_savers is not initial.
  "merge dvm_savers with savers such that merged savers are grouped by root and dvm_savers are at the end
  "of the groups
  sort dvm_savers by root.
  data merged_savers type tt_saver.
  loop at savers assigning field-symbol(<saver_group>) group by ( root = <saver_group>-root ).
    loop at group <saver_group> assigning <saver>.
      append <saver> to merged_savers.
    endloop.
    read table dvm_savers with key root = <saver_group>-root assigning
      field-symbol(<dvm_saver>) binary search.
    if sy-subrc = 0.
     data(ltabix) = sy-tabix.
     append <dvm_saver> to merged_savers.
     delete dvm_savers index ltabix.
    endif.
  endloop.
  append lines of dvm_savers to merged_savers.
  savers = merged_savers.
  clear: dvm_savers, merged_savers.
endif.  " DVM savers treatment

if with_savers is initial or saver_collector is initial.
  return.
endif.
"assert saver_collector is bound.  " violated by old tester


" === Store (visible) savers in central saver collector
loop at savers assigning <saver>.

  assign saver_collector->savers[ key ksav components saver = <saver>-saver ] to field-symbol(<csaver>).
  if sy-subrc = 0.
    if ACC_MODIFY is not initial or <csaver>-ACC_MODIFY is initial.
      " base (INDIRECT) MODIFY access overrules DIRECT MODIFY/READ access
      " base (INDIRECT) READ   access overrules DIRECT READ        access
      <csaver>-ACC_DIRECT = CMIN( val1 = <csaver>-ACC_DIRECT val2 = ACC_DIRECT ).
    endif.
    " MODIFY access overrules READ access
    <csaver>-ACC_MODIFY = CMAX( val1 = <csaver>-ACC_MODIFY val2 = ACC_MODIFY ).
  else.
    insert <saver> into table saver_collector->savers assigning <csaver>.
  endif.

  if acc_modify is not initial and curr_saver <> <csaver>-saver " don't repeat FINALIZEs that MODIFY own BO
      and <csaver>-finalize_multi is not initial. " cycle-detection only for repeatable FINALIZE (for compatibility,
                                                  " and non-repeatable FINALIZEs stop the cycle anyway)
    data cycle type string.
    clear cycle.
    if curr_saver is bound. " SAVER triggering SAVER: check for cyclic dependencies
      assign saver_collector->saver_call_graph[ saver = <csaver>-saver ] to field-symbol(<saver_graph_node>).
      if sy-subrc <> 0.
        insert value if_abap_behv_saver_collector=>t_saver_called_by( saver = <csaver>-saver )
            into table saver_collector->saver_call_graph
            assigning <saver_graph_node>.
      endif.
      insert curr_saver into table <saver_graph_node>-called_by.
      cycle = get_1st_saver_call_cycle( curr = curr_saver find = <csaver>-saver ).
      if cycle is not initial and cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-default.
        cl_abap_behv_tracer=>tracer->trace(
            procedure = 'GROUP_BEHV_BY_CLSS'
            message   = |{ text_010 } { cycle }| " Cyclic FINALIZE repetition:
            properties = value #( ( name = 'ROOT' value = <csaver>-root ) )
        ).
       endif.
    endif.
    assert fields cycle condition cycle is initial.

    <csaver>-finalize_status = co_finalize_repeat.
  endif.

endloop.

endmethod.


method INSTANTIATE_HANDLER
  by kernel module ab_km_behv_instantiate_handler ignore.
endmethod.


method INSTANTIATE_SAVER
  by kernel module ab_km_behv_instantiate_saver ignore.
endmethod.


method KINDSTRING.

case kind.
  when 'M'. str = `Modify` ##NO_TEXT.
  when 'R'. str = `Read` ##NO_TEXT.
  when 'L'. str = `Lock` ##NO_TEXT.
  when 'F'. str = `IFeatures` ##NO_TEXT.
  when 'G'. str = `GFeatures` ##NO_TEXT.
  when 'a'. str = `IAuth` ##NO_TEXT.
  when 'J'. str = `GAuth` ##NO_TEXT.
  when 'P'. str = `Precheck` ##NO_TEXT.
  when 'D'. str = `Determination` ##NO_TEXT.
  when 'V'. str = `Validation` ##NO_TEXT.
  when 'y'. str = `DetOnModify` ##NO_TEXT.
  when 'd'. str = `DetOnSave` ##NO_TEXT.
  when 'v'. str = `ValOnSave` ##NO_TEXT.
  when 'N'. str = `EarlyNumb` ##NO_TEXT.
  when others.
    str = kind.
endcase.

endmethod.


method LINECOUNT.

field-symbols <tab> type index table.

do.
  assign component sy-index of structure struc to <tab>.
  if sy-subrc <> 0.  exit.  endif.
  count = count + lines( <tab> ).
enddo.

endmethod.


method LOAD_IMPLEMENTATIONS.

data impl_ops   type tt_d010behv.
data impl_order type tt_d010behv.
data impl_lock  type tt_d010behv.

data(nob) = cond sychar01( when no_buffer is not initial
 then cond #( when no_dump is not initial then 'x' else 'X' )
 else cond #( when no_dump is not initial then 'C' ) ).  " catch generation error

GET_IMPLEMENTATIONS_KRN( exporting root_entity = root_entity
                                   no_buffer   = nob
                         importing rc          = rc
                                   timestamp   = timestamp
                         changing  impl_ops    = impl_ops
                                   impl_order  = impl_order
                                   impl_lock   = impl_lock ).

entries = lines( impl_ops ) + lines( impl_order ) + lines( impl_lock ).

if content is requested.
  content = impl_ops.
  if exclude na 'L'.
    insert lines of impl_lock into table content.
  endif.
  if exclude na 'o'.
    insert lines of impl_order into table content.
  endif.
endif.

endmethod.


method OBJECTDESCR.

data objid type i.

data(descr) = cl_abap_objectdescr=>describe_by_object_ref( obj ).
data(rname) = descr->get_relative_name( ).
data(sname) = substring_after( val = rname sub = 'CL_ABAP_BEHV_' ).

if cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-expert.
  call 'OBJMGR_GET_INFO' id 'OPNAME' field 'GET_OBJID' id 'OBJID' field objid id 'OBJ' field obj.  "#EC CI_CCALL
  name = |\{o:{ objid }\} { cond #( when sname is initial then rname else sname ) }|.
else.
  name = cond #( when sname is initial then rname else sname ).
endif.

data(pool) = substring_before( val = descr->absolute_name sub = `\CLASS=` ).
if pool is not initial.
  name = |{ name } ({ substring_after( val = pool sub = `=` ) })|.
endif.

endmethod.


method RESET_SINGLETONS.

if handlers is not initial.
  clear hdlr_instances.
endif.

if savers is not initial.
  clear savr_instances.
endif.

endmethod.


method SET_SAVER_RESPONSE.

define clone_if_filled.
  assign &1->* to field-symbol(<_&1_o>).
  if <_&1_o> is not initial.
    create data &2-&1 like <_&1_o>.
    assign &2-&1->* to field-symbol(<_&1>).
    <_&1> = <_&1_o>.
  endif.
end-of-definition.

if saver_collector is initial.
  return.
endif.

assign saver_collector->savers_response[ saver = saver ] to field-symbol(<savres>).
if sy-subrc <> 0.
  insert value #( saver = saver ) into table saver_collector->savers_response assigning <savres>.
else.
  clear: <savres>-failed, <savres>-mapped, <savres>-reported.
endif.

<savres>-phase = phase.

if failed is not initial.
  clone_if_filled failed <savres>.
endif.
if mapped is not initial.
  clone_if_filled mapped <savres>.
endif.
if reported is not initial.
  clone_if_filled reported <savres>.
endif.

endmethod.


method SET_TEST_DOUBLE.

check_test_double_allowed( ).

assert unregister_root is initial or object is not bound.

if unregister_root is initial and object is not bound.
  " --- drop complete registry
  clear mock_instances.
  clear mock_entities.
  " remove all mock instances from handler cache
  delete hdlr_instances where lclsidx = mki-mocked.  "#EC CI_HASHSEQ
  delete savr_instances where lclsidx = mki-mocked.  "#EC CI_HASHSEQ
  return.
endif.

data(root_name) = cond abp_root_entity_name(
 when unregister_root is not initial then to_upper( unregister_root )
 when object is bound then to_upper( object->root_name ) ).

" remove existing mock instances for given root from handler cache
data(kinds) = conv sychar20( cl_abap_behv_handler_mock=>mocked_kinds ).
data(idx) = 0.
do. " for all behavior kinds (which have been mocked)
  if kinds+idx(1) is initial.  exit.  endif.
  delete table hdlr_instances with table key
   kind    = kinds+idx(1)  " 'M', 'R' etc.
   clsname = root_name     " sic
   lclsidx = mki-mocked    " constant
   methidx = 0.            " constant
  add 1 to idx.
enddo.
" remove existing mock instance for given root from saver cache
delete table savr_instances with table key
   clsname = root_name     " sic
   lclsidx = mki-mocked.   " constant

assign mock_instances[ root_name = root_name ] to field-symbol(<mock>).

if unregister_root is not initial.
  " --- unregister specific mock object
  if <mock> is assigned.
    clear <mock>-object.
  endif.
  return.
endif.

" --- register mock object
if <mock> is assigned.
  <mock>-object = object.
else.
  insert value #( root_name = root_name object = object )
   into table mock_instances assigning <mock>.
endif.

" --- compute mock behavior from BDEF load, unless already done for previous registration
" --- collect entities from mock behavior for quick lookup
if <mock>-behavior is initial.
  CL_ABAP_BEHV_HANDLER_MOCK=>get_behavior( exporting root     = root_name
                                           changing  behavior = <mock>-behavior
                                                     entities = mock_entities
                                         ).
endif.

endmethod.


method START_SAVER_COLLECTION.

" === re-initialize instances used up to preceding "commit"

if saver_execution is not initial.
  " possible reason: this call is triggered by a CLEANUP
  " - forced by CL_ABAP_BEHV_TRANSACTION_CTRL
  " -- which has detected a ROLLBACK WORK
  " --- executed during a SAVE_MODIFIED
  " then INITIALIZE on running savers must not be called; in particular,
  " the handler may be in a LOOP and the INITIALIZE clears the table -> dump
  " => just throw away the whole saver cache
  clear savr_instances.
else.
  loop at savr_instances assigning field-symbol(<saver>).
    if <saver>-lclsidx in mki_proj.
      data(proj_saver) = cast cl_abap_behv_saver_proj( <saver>-instance ).
      proj_saver->initialize( ).
    elseif <saver>-lclsidx = mki-csp_active.
      data(csp_saver) = cast cl_abap_behv_saver_mngd_csp( <saver>-instance ).
      csp_saver->initialize( ).
    elseif <saver>-lclsidx = mki-csp_draft.
      data(dsp_saver) = cast cl_abap_behv_saver_mngd_dsp( <saver>-instance ).
      dsp_saver->initialize( ).
    endif.
  endloop.
endif.

if collector is not initial.
  saver_collector =  collector.
else.
  saver_collector =  new lcl_saver_collector( ).
endif.

saver_collector->n_mapped_roots = -1.  " unknown; to be analyzed

endmethod.


method TRANSFER_TO_LOG.

constants no_entity_name type abp_entity_name value is initial.
constants skey_name type seckeyname value cl_abap_behv=>co_key_name-ENTITY.
constants key_name  type fieldname  value cl_abap_behv=>co_techfield_name-KEY.
constants msg_name  type fieldname  value cl_abap_behv=>co_techfield_name-MSG.

types: begin of t_src_map,
         src_idx type i,
         src_tab type ref to data,
         map_tab type ref to data,
       end of t_src_map.

field-symbols <m_enames> type data.
field-symbols <s_struc>  type data.
field-symbols <m_struc>  type data.
field-symbols <s_table>  type index table.
field-symbols <m_table>  type index table.
field-symbols <s_line>   type data.
field-symbols <ename>    type abp_entity_name.
field-symbols <alias>    type abp_entity_name.
field-symbols <s_msg>    type ref to if_abap_behv_message.
field-symbols <m_msg>    type ref to if_abap_behv_message.

data entity_idx          type i.
data dref                type ref to data.
data smsg_handler        type ref to IF_RAP_BHV_STATE_MSG_HANDLER.

clear removed_entities.
if kind = if_abap_behv_log=>reported or kind = if_abap_behv_log=>reported_late.
  do.  " iterate all components in source-REPORTED
    assign component sy-index of structure src_struc to <s_table>.
    if sy-subrc <> 0.  exit.  endif.  " all done
    check <s_table> is not initial.
    assign component sy-index of structure entity_name to <ename>.
    if sy-subrc <> 0.
      continue. " %OTHER
    endif.
    entity_idx = sy-index.
    clear dref.
    loop at <s_table> assigning <s_line> where (area_is_set).
      if reject_state_messages is not initial.
        raise shortdump type cx_abap_behv_runtime_error
          message e039 with <ename>
          exporting entity = <ename>.
      endif.
      if dref is initial.
        create data dref like <s_table>.
        assign dref->* to <m_table>.
      endif.
      insert <s_line> into table <m_table>.
      delete <s_table>.
    endloop.
    if <s_table> is initial.
      insert <ename> into table removed_entities.
    endif.
    if dref is not initial.
      if smsg_log is not initial.
        " delay of state messages for projection
        smsg_log->add( kind         = kind
                       root_name    = root_name
                       entity_name  = <ename>
                       entity_index = entity_idx
                       instances    = <m_table> ).
      else.
        if smsg_handler is initial.
          smsg_handler = cl_rap_bhv_msg_handler_factory=>get_state_message_handler( ).
        endif.
        smsg_handler->add( iv_entity_name = <ename>
                           it_instances   = <m_table>
                           io_log         = log ).
      endif.
      clear <m_table>.
    endif.
  enddo.
endif.

" === For REPORTED_LATE, execute MAP_MESSAGES of registered mappers
if do_map_messages is not initial
 and kind = if_abap_behv_log=>reported_late and saver_collector is not initial.
  data src_maps type standard table of t_src_map.
  field-symbols <area_reported> type t_data_area.
  field-symbols <reported>      type data.

  loop at saver_collector->mappers using key primary_key assigning field-symbol(<map>)
   where mapped_root = root_name.

    data(curr_map) = |\{{ root_name }->{ <map>-mapper-root }\}|.
    if currently_mapped cs curr_map.
      continue.  " cycle detected
    endif.

    " --- only OWN entities of ROOT_NAME are mapped
    get_own src_struc <s_struc>.

    get_data_area_late REPORTED <map>-mapper-root.  " assign <REPORTED>

    data(mm_root) = conv program( <map>-mapper-root ).
    overlay mm_root with '==============================BD'.
    perform nottobefound in program (mm_root) if found.
    data(fgn_cname) = |({ mm_root })%FGNNAME-{ root_name }|.
    assign (fgn_cname) to field-symbol(<fgn_names>).
    check sy-subrc = 0.  " ASSERT

    do.  " iterate all filled (OWN) components in source-REPORTED
      assign component sy-index of structure <s_struc> to <s_table>.
      if sy-subrc <> 0.  exit.  endif.  " all done
      check <s_table> is not initial.
      assign component sy-index of structure entity_name to <ename>.
      assert sy-subrc = 0.
      assign component <ename> of structure <fgn_names> to <alias>.
      if sy-subrc <> 0.
        continue.  " <ename> is not a FOREIGN entity in mapper-REPORTED
      endif.
      assign component <alias> of structure <reported> to <m_table>.
      assert sy-subrc = 0.
      <m_table> = <s_table>.
      insert value t_src_map( src_idx = sy-index
                              src_tab = ref #( <s_table> )
                              map_tab = ref #( <m_table> ) )
       into table src_maps.
    enddo.

    data(th) = cond t_trace_hier(
     when cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-essential
     then value #(
      let _msg = |{ text_004 } ({ phase } / { text_005 }) { objectdescr( <map>-mapper-saver ) }| in ##TYPE
       msg  = _msg
       nest = cl_abap_behv_tracer=>tracer->trace_beg( trace_level = cl_abap_behv_tracer=>c_xtrace-essential
       message = _msg
       procedure = 'TRANSFER_TO_LOG'
       properties = value #( ( name = 'PATH' value = currently_mapped && curr_map )
                             ( name = 'REPORTED' value = |{ linecount( <reported> ) }| )
                           ) ) ) ).

    system-call debugger set system path suspend.  "#EC CI_SYSTEMCALL
    <map>-mapper-saver->in_phase = phase.
    <map>-mapper-saver->MAP_MESSAGES( changing reported = <reported> ).
    system-call debugger set system path resume.  "#EC CI_SYSTEMCALL

    " --- recursion: log OWN entries produced by mapper
    get_OWN <reported> <m_struc>.
    "data(cnt_own) = linecount( <m_struc> ).
    if <m_struc> is not initial.
      get_entityname_struc <m_enames> <map>-mapper-root.
      " Extra log object for EML COMMIT exists? (same logic as in CALL_SAVER)
      " (OTHER_LOG no longer relevant: was determined for the original root)
      set_eml_commit_log  curr_log  <map>-mapper-root log.
      data(no_base_proj) = xsdbool( <map>-projectors is initial ).
      data(new_curr_map) = currently_mapped && curr_map.
      transfer_to_log( exporting log         = log
                                 other_log   = curr_log  " wrong: other_log
                                 kind        = kind  " = REPORTED_LATE
                                 root_name   = <map>-mapper-root
                                 entity_name = <m_enames>
                                 discard_afterwards = no_base_proj
                                 flavor      = cond #( when no_base_proj is initial
                                                       then if_abap_behv_log=>BASE )
                                 phase       = phase
                            currently_mapped = new_curr_map
                       changing  src_struc   = <m_struc> ).
      if no_base_proj is initial.
        " The messages mapped to <MAP>-MAPPER-ROOT must also be mapped to the
        " projection(s) sitting on top of it in the current transaction
        loop at <map>-projectors into data(proj_saver).
          get_entityname_struc <m_enames> proj_saver->m_root.
          set_eml_commit_log  proj_log  proj_saver->m_root log.
          data(r_proj_reported) = cl_abap_behvdescr=>create_data(
                                    p_root = proj_saver->m_root
                                    p_op   = cl_abap_behvdescr=>op_reported_late ).
          assign r_proj_reported->* to field-symbol(<proj_reported>).
          proj_saver->trans_reported( exporting base_reported = <reported>
                                      changing  reported      = <proj_reported> ).
          transfer_to_log( exporting log         = log
                                     other_log   = proj_log
                                     kind        = kind
                                     root_name   = proj_saver->m_root
                                     entity_name = <m_enames>
                                     discard_afterwards = 'X'
                                     flavor      = if_abap_behv_log=>PROJECTION
                                     phase       = phase
                                currently_mapped = |{ new_curr_map }| &
                                                   |\{{ root_name }->{ proj_saver->m_root }\}|
                           changing  src_struc   = <proj_reported> ).
        endloop.
      endif.
    endif.

    if th is not initial.
      cl_abap_behv_tracer=>tracer->trace_end( hierarchy_number = th-nest
       "message = |<{ th-msg }|
       "properties = value #( ( name = 'OWN_REPORTED' value = |{ cnt_own }| ) )
      ).
    endif.

    " --- adjust source-REPORTED:
    "     - delete lines deleted by mapper
    "     - exchange msg object where exchanged by mapper
    loop at src_maps assigning field-symbol(<src_map>).
      assign <src_map>-src_tab->* to <s_table>.
      assign <src_map>-map_tab->* to <m_table>.
      " prepare for 'loop into'
      create data dref like line of <s_table>.
      assign dref->* to <s_line>.
      assign component key_name of structure <s_line> to field-symbol(<s_key>).
      assign component msg_name of structure <s_line> to <s_msg>.
      loop at <s_table> into <s_line>.
        data(s_idx) = sy-tabix.
        read table <m_table> with key (skey_name)
         components (key_name) = <s_key> assigning field-symbol(<m_line>).
        if sy-subrc <> 0.
          " line was deleted by mapper: delete in original table
          delete <s_table>.
        else.
          assign component msg_name of structure <m_line> to <m_msg>.
          if <s_msg> <> <m_msg>.
            " msg object was exchanged by mapper: exchange in original table
            assign <s_table>[ s_idx ] to field-symbol(<s_curr>).
            assign component msg_name of structure <s_curr> to field-symbol(<o_msg>).
            <o_msg> = <m_msg>.
          endif.
        endif.
      endloop.
    endloop.
    clear src_maps.

  endloop.
endif.

" Iterate all components of SAVER/HANDLER structure (one per entity)
" and move entries to generic log table (key = root/entity)

data wrapping_log type ref to IF_ABAP_BEHV_LOG_WRAPPING.
if other_log is not initial and log is instance of IF_ABAP_BEHV_LOG_WRAPPING.
  wrapping_log ?= log.
  wrapping_log->wrap_log = other_log.
endif.

entity_idx = 1.
do.
  assign component entity_idx of structure src_struc to <s_table>.
  if sy-subrc <> 0.
    exit.  " all entities (components of source structure) processed
  endif.
  assign component entity_idx of structure entity_name to <ename>.
  if sy-subrc <> 0.
    assign no_entity_name to <ename>. " %OTHER component in REPORTED
  endif.
  if <s_table> is not initial.
    if set_messages_global is not initial.
      " set %GLOBAL flag in REPORTED tables if not done by provider
      data(set_idx) = 0.
      loop at <s_table> assigning field-symbol(<s_rep>).
        assign component cl_abap_behv=>co_techfield_name-msg_global of structure <s_rep>
         to field-symbol(<s_glob>).
        if sy-subrc = 0 and <s_glob> is initial.
          set_idx = sy-tabix. exit.
        endif.
      endloop.
      if set_idx <> 0.
        data clon_rep type ref to data.                  create data clon_rep like <s_table>.
        assign clon_rep->* to field-symbol(<clon_tab>).  <clon_tab> = <s_table>.
        assign clon_rep->* to <s_table>.
        loop at <s_table> from set_idx assigning <s_rep>.
          assign component cl_abap_behv=>co_techfield_name-msg_global of structure <s_rep> to <s_glob>.
          <s_glob> = if_abap_behv=>mk-on.
        endloop.
      endif.
    endif.
    log->ADD( kind         = kind
              root_name    = root_name
              entity_name  = <ename>
              entity_index = entity_idx
              instances    = <s_table>
              flavor       = flavor ).
    if other_log is not initial and wrapping_log is initial.
      other_log->ADD( kind         = kind
                      root_name    = root_name
                      entity_name  = <ename>
                      entity_index = entity_idx
                      instances    = <s_table>
                      flavor       = flavor ).
    endif.
    if discard_afterwards is not initial.
      clear <s_table>.  " clear source table
    endif.
  elseif wrapping_log = log
     and line_exists( removed_entities[ table_line = <ename> ] ).
    " call with empty instance table is needed for state message handling
    log->ADD( kind         = kind
              root_name    = root_name
              entity_name  = <ename>
              entity_index = entity_idx
              instances    = <s_table>  " initial
              flavor       = flavor ).
  endif.
  add 1 to entity_idx.
enddo.

if wrapping_log is not initial.
  clear wrapping_log->wrap_log.
endif.

endmethod.


method ADD_INSTANCE_REFS.

assert curr_proj_hdlr is bound.

curr_proj_hdlr->add_instance_refs( exporting inst_refs = inst_refs bdef = bdef ).

endmethod.


  method call_authority_checks.
    clear error_pools.

    if job is initial or job->activities is initial.
      return.
    endif.

    job->close( exporting all_root_entities = all_root_entities
                               mock_instances    = mock_instances
                               hdlr_restriction  = hdlr_restriction ).

    xtrace_triggers job 'CALL_AUTHORITY_CHECKS'.

    group_behv_by_clss( exporting job              = job
                                  collect_savers   = 'X'  " for CLEANUP registration
                        importing handler_sigs     = data(hdlr_sigs)
                                  trigger_handlers = data(trig_hdlrs)
                        changing  error_pools      = error_pools ).

    get_handlers_in_actv_order( exporting job         = job
                                          actv_trigs  = job->actv_trigs
                                          trig_hdlrs  = trig_hdlrs
                                importing handlers    = data(handlers)
                                changing  hdlr_sigs   = hdlr_sigs
                                          unhandled   = job->unhandled_activities
                                          error_pools = error_pools ).

    dump_on_error_pools err.

    data has_proj type sychar01.
    data has_non_proj type sychar01.
    loop at handlers assigning field-symbol(<hdlr>).
      " --- Params have been split for implementation GROUPS (in GET_HANDLERS_IN_ACTV_ORDER)
      "     Group results are merged directly in call below (else wouldn't work for projection)
      call_handler( job     = job
                    handler = <hdlr>-handler
                    params  = ref #( <hdlr>-params )
                    root    = <hdlr>-root
                  ).
      if <hdlr>-handler_idx in mki_proj.
        has_proj = 'X'.
      else.
        has_non_proj = 'X'.
      endif.
    endloop.

    if has_proj is not initial and has_non_proj is not initial.
      loop at handlers assigning <hdlr>.
      " --- merge projection local results and projection base results
      merge_handler_results( job     = job
                             handler = <hdlr>-handler
                             params  = ref #( <hdlr>-params )
                           ).
      endloop.
    endif.

  endmethod.


method CALL_COLLECTED_SAVERS.

types: begin of t_base_proj,
         base type ref to CL_ABAP_BEHAVIOR_SAVER,
         proj type ref to CL_ABAP_BEHV_SAVER_PROJ,
       end of t_base_proj.

data base_projs type sorted table of t_base_proj with unique key base proj.
data indirects type standard table of ref to t_saver with empty key.
data handled_roots type tt_entity_uniq.
data repeat type c length 1 value 'X'.

field-symbols <saver> like line of saver_collector->savers.
field-symbols <fgn_root> type abp_root_entity_name.

if saver_collector is initial.
  return.
endif.

clear saver_collector->savers_response.

" Organizational stuff only done in the first SAVE phase
if saver_collector->n_mapped_roots < 0.

  saver_collector->n_mapped_roots = 0.
  clear saver_collector->mappers.

  " === Collect PROJ savers per BASE saver;
  "     promote PROJ savers from direct-READ to direct-MODIFY access
  "     where the BASE saver was collected with MODIFY
  loop at saver_collector->savers reference into data(r_saver).
    case type of r_saver->saver.
      when type CL_ABAP_BEHV_SAVER_PROJ into data(proj_saver).
        loop at proj_saver->M_BASE_SAVERS assigning field-symbol(<base_saver>).
          insert value #( base = <base_saver>-saver proj = proj_saver )
           into table base_projs.
          check r_saver->ACC_MODIFY is initial
            and r_saver->ACC_DIRECT is not initial.
          assign saver_collector->savers[ key ksav components saver = <base_saver>-saver ]
           to field-symbol(<coll_bsaver>).
          check sy-subrc = 0
            and <coll_bsaver>-ACC_MODIFY is not initial.
          r_saver->ACC_MODIFY = <coll_bsaver>-ACC_MODIFY.
          exit.
        endloop.
      when others.
        if r_saver->ACC_DIRECT is initial.
          insert r_saver into table indirects.
        endif.
    endcase.
  endloop.

  " === Promote INDIRECT BASE savers to DIRECT where not covered by PROJ
  "     this happens when a projection-level action is the only access (doesn't go thru generic proj handler)
  loop at indirects assigning field-symbol(<indi_saver>).
    if line_exists( base_projs[ base = <indi_saver>->saver ] ).
      continue.
    endif.
    <indi_saver>->ACC_DIRECT = 'X'.
  endloop.

  " === Collect message mappers
  loop at saver_collector->savers assigning <saver>.
    if <saver>-saver->meth-MAP_MESSAGES = not_implemented.
      continue.  " saver has no MAP_MESSAGES method
    endif.
    data(mm_root) = conv program( <saver>-root ).
    overlay mm_root with '==============================BD'.
    perform nottobefound in program (mm_root) if found.
    data(fgn_cname) = |({ mm_root })%FGNROOT|.
    assign (fgn_cname) to field-symbol(<fgn_struc>).
    if sy-subrc <> 0.
      continue.  " <saver>-root contains no foreign root entity at all
    endif.
    do.  " iterate all foreign root entities of <saver>-root
      assign component sy-index of structure <fgn_struc> to <fgn_root>.
      if sy-subrc <> 0.  exit.  endif.
      if not line_exists( saver_collector->savers[ key kroo root = <fgn_root> ] ).
        continue.  " there is no saver for <fgn_root> -> ignore this mapping
      endif.
      if not line_exists( saver_collector->mappers[ key primary_key mapped_root = <fgn_root> ] ).
        add 1 to saver_collector->n_mapped_roots.  " just a counter
      endif.
      insert value #( mapped_root = <fgn_root> mapper = <saver> )
       into table saver_collector->mappers assigning field-symbol(<mapper>).
      " remember PROJ saver(s) sitting on top of this saver/mapper
      loop at base_projs using key primary_key assigning field-symbol(<base_proj>) where base = <saver>-saver.
        insert <base_proj>-proj into table <mapper>-projectors.
      endloop.
    enddo.
  endloop.

  if cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-default and saver_collector->mappers is not initial.
    cl_abap_behv_tracer=>tracer->add_header_properties(
     value #( ( name = 'BEHV' value = 'MapMessages' ) ) ).
    cl_abap_behv_tracer=>tracer->trace(
     message   = |{ text_008 } ({ lines( saver_collector->mappers ) })|
     procedure = 'CALL_COLLECTED_SAVERS'
     content   = saver_collector->mappers ).
  endif.

  clear: base_projs, indirects, r_saver.
endif.  " organizational stuff only done in the first phase

" === Execute savers with direct MODIFY access (CLEANUP phase also for READ access)

add 1 to saver_execution.

while repeat is not initial.
  clear repeat.

  loop at saver_collector->savers assigning <saver>
      where acc_direct is not initial. " skip savers called via the projection saver

    if <saver>-ACC_MODIFY is initial.
      " this saver was registered only with "READ" access
      if phase <> if_abap_behv=>phases-CLEANUP.
        continue.
      endif.
    endif.

    if phase = if_abap_behv=>phases-finalize.
      if <saver>-finalize_status = co_finalize_done.
        continue.
      endif.
      <saver>-finalize_status = co_finalize_done.
      repeat = 'X'. " FINALIZEs might trigger MODIFYs => might need to repeat the loop
    endif.

    call_saver( exporting saver = <saver>-saver
                          root  = <saver>-root
                          phase = phase
                          log   = log
                importing is_void = data(is_void) ).

    if phase = if_abap_behv=>phases-save.  " implementation of this phase is mandatory
      if is_void is not initial.
        " This unmanaged saver doesn't implement Save, but it may be that Save is implemented
        " by a managed saver, and the unmanaged saver is just for MAP_MESSAGES.
        " In that case, this "unhandled" entry will be deleted again (below).
        insert <saver>-root into table unhandled_roots.
      else.
        insert <saver>-root into table handled_roots.
      endif.
    endif.

  endloop.

endwhile.

unhandled_roots = filter #( unhandled_roots except in handled_roots where table_line = table_line ).

case phase.
  when if_abap_behv=>phases-finalize.
    loop at saver_collector->savers assigning <saver>.
      <saver>-finalize_status = co_finalize_not_run.
    endloop.
    cl_abap_behv_detval=>check_finalize_is_complete( ).
  when if_abap_behv=>phases-CLEANUP.
    cleanup_krn( ).
    cl_abap_behv_detval=>cleanup( ).
    cl_abap_behv_tracer=>tracer->get_trace_level( ).
endcase.

subtract 1 from saver_execution.

endmethod.


method CALL_EARLY_NUMBERING.

clear error_pools.

if job is initial or job->activities is initial.
  return.
endif.

job->close( exporting all_root_entities = all_root_entities
                      mock_instances    = mock_instances ).

xtrace_triggers job 'CALL_EARLY_NUMBERING'.

GROUP_BEHV_BY_CLSS( exporting job              = job
                              collect_savers   = 'X'  " for CLEANUP registration
                    importing handler_sigs     = data(hdlr_sigs)
                              trigger_handlers = data(trig_hdlrs)
                    changing  error_pools      = error_pools ).

GET_HANDLERS_IN_ACTV_ORDER( exporting job         = job
                                      actv_trigs  = job->actv_trigs
                                      trig_hdlrs  = trig_hdlrs
                            importing handlers    = data(handlers)
                            changing  hdlr_sigs   = hdlr_sigs
                                      unhandled   = job->unhandled_activities
                                      error_pools = error_pools ).

dump_on_error_pools err.

" === Call handlers in sequence
loop at handlers assigning field-symbol(<hdlr>).
  call_handler( job     = job
                handler = <hdlr>-handler
                params  = ref #( <hdlr>-params )
                root    = <hdlr>-root
              ).
endloop.

endmethod.


method call_global_authorization.

  clear error_pools.

  if job is initial or job->activities is initial.
    return.
  endif.

  job->close( exporting all_root_entities = all_root_entities
                             mock_instances    = mock_instances
                             hdlr_restriction  = hdlr_restriction ).

  xtrace_triggers job 'CALL_GLOBAL_AUTHORIZATION'.

  group_behv_by_clss( exporting job              = job
                                collect_savers   = ' '  " no savers for 'global' job
                      importing handler_sigs     = data(hdlr_sigs)
                                trigger_handlers = data(trig_hdlrs)
                      changing  error_pools      = error_pools ).

  get_handlers_in_actv_order( exporting job         = job
                                        actv_trigs  = job->actv_trigs
                                        trig_hdlrs  = trig_hdlrs
                              importing handlers    = data(handlers)
                              changing  hdlr_sigs   = hdlr_sigs
                                        unhandled   = job->unhandled_activities
                                        error_pools = error_pools ).

  dump_on_error_pools err.

  data has_proj type sychar01.
  data has_non_proj type sychar01.
  loop at handlers assigning field-symbol(<hdlr>).
    " --- Params have been split for implementation GROUPS (in GET_HANDLERS_IN_ACTV_ORDER)
    "     Group results are merged directly in call below (else wouldn't work for projection)
    call_handler( job     = job
                  handler = <hdlr>-handler
                  params  = ref #( <hdlr>-params )
                  root    = <hdlr>-root
                ).
    if <hdlr>-handler_idx in mki_proj.
      has_proj = 'X'.
    else.
      has_non_proj = 'X'.
    endif.
  endloop.

  if has_proj is not initial and has_non_proj is not initial.
    loop at handlers assigning <hdlr>.
    " --- merge projection local results and projection base results
    merge_handler_results( job     = job
                           handler = <hdlr>-handler
                           params  = ref #( <hdlr>-params )
                         ).
    endloop.
  endif.

endmethod.


method call_global_controllers.

  clear error_pools.

  if job is initial or job->activities is initial.
    return.
  endif.

  job->close( exporting all_root_entities = all_root_entities
                        mock_instances    = mock_instances
                        hdlr_restriction  = hdlr_restriction ).

  xtrace_triggers job 'CALL_GLOBAL_CONTROLLERS'.

  group_behv_by_clss( exporting job              = job
                                collect_savers   = ' '  " no savers for 'global' job
                      importing handler_sigs     = data(hdlr_sigs)
                                trigger_handlers = data(trig_hdlrs)
                      changing  error_pools      = error_pools ).

  get_handlers_in_actv_order( exporting job         = job
                                        actv_trigs  = job->actv_trigs
                                        trig_hdlrs  = trig_hdlrs
                              importing handlers    = data(handlers)
                              changing  hdlr_sigs   = hdlr_sigs
                                        unhandled   = job->unhandled_activities
                                        error_pools = error_pools ).

  dump_on_error_pools err.

  data has_proj type sychar01.
  data has_non_proj type sychar01.
  loop at handlers assigning field-symbol(<hdlr>).
    " --- Params have been split for implementation GROUPS (in GET_HANDLERS_IN_ACTV_ORDER)
    "     Group results are merged directly in call below (else wouldn't work for projection)
    call_handler( job     = job
                  handler = <hdlr>-handler
                  params  = ref #( <hdlr>-params )
                  root    = <hdlr>-root
                ).
    if <hdlr>-handler_idx in mki_proj.
      has_proj = 'X'.
    else.
      has_non_proj = 'X'.
    endif.
  endloop.

  if has_proj is not initial and has_non_proj is not initial.
    loop at handlers assigning <hdlr>.
    " --- merge projection local results and projection base results
    merge_handler_results( job     = job
                           handler = <hdlr>-handler
                           params  = ref #( <hdlr>-params )
                         ).
    endloop.
  endif.

endmethod.


method CALL_HANDLER.

data stdpar      type cl_abap_behavior_handler=>t_std_param.
data lock_params type tt_handler_param.
data lock_param  type t_handler_param.
data dummy_img   type if_abap_behv=>t_image.

field-symbols <par>            type t_handler_param.
field-symbols <actv>           type ABP_BEHV_ACTIVITIES.
field-symbols <area_failed>    type t_data_area.
field-symbols <failed>         type data.
field-symbols <area_mapped>    type t_data_area.
field-symbols <mapped>         type data.
field-symbols <area_reported>  type t_data_area.
field-symbols <reported>       type data.
field-symbols <area_entitykey> type t_data_area.
field-symbols <entitykey>      type data.
field-symbols <enames>         type data.
field-symbols <tab>            type data.
field-symbols <callparams>     type tt_handler_param.

if handler->kind = 'L'.

* === Lock handler: Must extract keys from activities to prepare real call params

  assign lock_params to <callparams>.

  get_data_area_shared ENTITYKEY root.  " assign <ENTITYKEY>
  get_entityname_struc <enames> root.
  if <enames> is not assigned.  return.  endif.  " can't go on... TODO: ASSERT (should not occur)

  loop at params->* assigning <par>.
    if <par>-instances is initial.
      continue.  " static action w/o parameter
    endif.
    assign <par>-instances->* to field-symbol(<par_instances>).
    if <par_instances> is initial.
      continue.
    endif.
    describe field <par_instances> type data(idt).
    if idt <> 'h'.
      continue.  " static action with non-table parameter
    endif.
    " NB: <ENTITYKEY> components are entity names (not BDL aliases)
    assign job->activities[ <par>-actv_idx ] to <actv>.
    assign component <actv>-entity_name of structure <entitykey>
     to field-symbol(<ekey>).
    " NB: Each entity occurs at most once (it IS the trigger for the LOCK)
    move-corresponding <par_instances> to <ekey>.
    lock_param = <par>.
    lock_param-instances = ref #( <ekey> ).
    append lock_param to lock_params.
  endloop.

  if lock_params is initial.
    return.  " no instances to lock
  endif.

else.

  assign params->* to <callparams>.

*   === Before handler invocation: Create missing RESULTS and/or LINKS (for ACTION / READ)
  loop at <callparams> assigning <par>.
    if <par>-results is not initial.
      " RESULTS are never *input*
      assign <par>-results->* to <tab>.
      clear <tab>.
    elseif <par>-result_idx >= 0 and <par>-full <> 'L'.
      " RESULTS are required and must be created
      assign job->activities[ <par>-actv_idx ] to <actv>.
      CL_ABAP_BEHVDESCR=>CREATE_DATA( exporting p_name     = <actv>-entity_name
                                                p_root     = root
                                                p_op       = <actv>-op
                                                p_sub_name = <actv>-sub_name
                                                p_kind     = if_abap_behv=>typekind-result
                                      receiving p_data     = <par>-results ).
      <actv>-results = <par>-results.
    endif.
    if <par>-op = op-read_ba.
      " LINKS are *output* for READ_BA (but *input* for CREATE_BA)
      if <par>-links is not initial.
        assign <par>-links->* to <tab>.
        clear <tab>.
      " NOTE: If <ACTV>-OP supports LINKS at all, then RESULT_IDX >= 0 and <PAR>-FULL <> ' '
      elseif <par>-result_idx >= 0 and <par>-full <> ' '.
        assign job->activities[ <par>-actv_idx ] to <actv>.
        CL_ABAP_BEHVDESCR=>CREATE_DATA( exporting p_name     = <actv>-entity_name
                                                  p_root     = root
                                                  p_op       = <actv>-op
                                                  p_sub_name = <actv>-sub_name
                                                  p_kind     = if_abap_behv=>typekind-link
                                        receiving p_data     = <par>-links ).
        <actv>-links = <par>-links.
      endif.
    endif.
  endloop.

endif.

unassign: <par>, <tab>.

if job->m_from_projection is initial
 and cl_abap_behv_job_base=>curr_p_b_job is not initial
 and cl_abap_behv_job_base=>curr_p_b_job->actv_roots = job->actv_roots.
  job->m_from_projection = cl_abap_behv_job_base=>curr_p_b_job->m_from_projection.
endif.

data(prev_context) = cl_abap_behv_aux=>g_curr_context.
cl_abap_behv_aux=>g_curr_context =
 value #( in_local_mode   = job->m_in_local_mode
          privileged      = job->m_privileged
          draft_activate  = job->m_draft_activate
          for_permissions = job->m_for_permissions
          from_projection = job->m_from_projection  " adjusted above
 ).

" --- The actual handler invocation ---

try.

  insert handler into table busy_hdlr_instances.

  if handler->kind ca 'ydv'.
    " --- New (DVM) determinations and validations use LATE response types
    get_data_area_late FAILED   root.  " assign <FAILED>
    get_data_area_late REPORTED root.  " assign <REPORTED>

    stdpar-r_failed   = <area_failed>-ref.
    stdpar-r_reported = <area_reported>-ref.

  elseif handler->kind = 'V'.

    " --- Pre-DVM validation uses one FAILED/REPORTED *table*, not the *struc*
    get_data_area_late FAILED   root.  " assign <FAILED>
    get_data_area_late REPORTED root.  " assign <REPORTED>

    " --- Assuming that parameter 1 holds the assigned entity !
    get_entity_index( exporting entity_name  = job->activities[ <callparams>[ 1 ]-actv_idx ]-entity_name
                                root_name    = root
                      importing entity_index = data(assigned_index) ).
    if assigned_index = 0.  return.  endif.  " can't go on... TODO: ASSERT (should not occur)
    assign <area_failed>-ref->* to field-symbol(<struc_f>).
    assign component assigned_index of structure <struc_f> to field-symbol(<comp_f>).
    stdpar-r_failed = ref #( <comp_f> ).
    assign <area_reported>-ref->* to field-symbol(<struc_r>).
    assign component assigned_index of structure <struc_r> to field-symbol(<comp_r>).
    stdpar-r_reported = ref #( <comp_r> ).
    unassign: <struc_f>, <struc_r>, <comp_f>, <comp_r>.

  else.

    get_data_area FAILED   root.  " assign <FAILED>
    get_data_area MAPPED   root.  " assign <MAPPED>
    get_data_area REPORTED root.  " assign <REPORTED>

    stdpar-r_failed   = <area_failed>-ref.
    stdpar-r_mapped   = <area_mapped>-ref.
    stdpar-r_reported = <area_reported>-ref.
    stdpar-r_image    = ref #( dummy_img ).
  endif.

  stdpar-root = root.

  data(th) = cond t_trace_hier(
   let _lev = cond #( when handler->meth = 0 then cl_abap_behv_tracer=>c_xtrace-default else cl_abap_behv_tracer=>c_xtrace-extended ) in
   when cl_abap_behv_tracer=>xtrace_level >= _lev then value #(
   let _msg = |{ text_004 } ({ handler->kind
               }{ cond #( when job->m_in_local_mode is not initial then `/LM` )
               }) { objectdescr( handler ) }|
       __prp = value IF_SXT_TYPES=>TY_PROPERTY_TAB(
               ( name = 'ROOT' value = stdpar-root )
               ( name = 'KIND' value = kindstring( handler->kind ) ) )
       _prp  = cond #( when job->m_privileged is initial then __prp
                          else value #( base __prp
                                        ( name = 'PRIVILEGED' value = 'X' ) ) )
   in
    msg  = _msg
    nest = cl_abap_behv_tracer=>tracer->trace_beg(
     trace_level = _lev  message = _msg
     procedure = 'CALL_HANDLER'
     properties = cond #( when job->m_in_local_mode is initial then _prp
                          else value #( base _prp
                                        ( name = 'LOCAL_MODE' value = 'X' ) ) ) ) ) ).

  if handler->meth = 0.  " %MANAGED

    cast CL_ABAP_BEHV_HANDLER_GENERIC( handler
                )->EXECUTE( exporting kind   = handler->kind
                                      job    = job
                                      stdpar = stdpar
                                      params = <callparams> ).

  else.

    system-call debugger set system path suspend.  "#EC CI_SYSTEMCALL

    handler->invoke( exporting std      = stdpar
                     changing  params   = <callparams> ).

    system-call debugger set system path resume.  "#EC CI_SYSTEMCALL

  endif.

  if th is not initial.
    cl_abap_behv_tracer=>tracer->trace_end( hierarchy_number = th-nest  message = |<{ th-msg }|  properties = value #(
     let _props = value if_sxt_types=>ty_property_tab(
      ( name = 'FAILED'   value = |{ cond #( when <failed>   is assigned then linecount( <failed> ) ) }| )
      ( name = 'MAPPED'   value = |{ cond #( when <mapped>   is assigned then linecount( <mapped> ) ) }| )
      ( name = 'REPORTED' value = |{ cond #( when <reported> is assigned then linecount( <reported> ) ) }| ) )
     in for <_p> in _props where ( value <> '0' ) ( <_p> ) ) ).
  endif.

  " --- Postprocessing ---

  constants discard_after type sychar01 value 'X'.
  constants flavor type if_abap_behv_log=>t_flavor value if_abap_behv_log=>unspecific.
  constants none type if_abap_behv=>t_phase value is initial.

  data(handler_kind) = handler->kind.
  if <failed> is not initial.
    if job->m_level = cl_abap_behv_job_base=>MODIFY_AUGM.
      " inform PROJ handler about instances failed in augmentation
      curr_proj_hdlr->ADD_AUGMENT_FAILED( <failed> ).
    endif.
    " FAIL_LOG is provided as an extra response channel by CALL_PRECHECKERS
    postprocess <enames> root failed job->log fail_log none discard_after flavor handler_kind.
  endif.
  if <mapped> is assigned and <mapped> is not initial.
    if job->m_DRAFT_ACTIVATE is not initial and job->m_FROM_PROJECTION is not initial
     and job is instance of cl_abap_behv_job.  " e.g. NUMBERING job
      cl_abap_behv_handler_proj=>TRANSFER_STRUC_TO_PROJ_LOG(
          kind           = if_abap_behv_log=>mapped
          proj_root      = job->m_FROM_PROJECTION
          base_root      = root
          base_response  = <mapped>
          log            = job->log ).
    endif.
    postprocess <enames> root mapped job->log no_log none discard_after flavor handler_kind.
  endif.
  if <reported> is not initial.
    if handler_kind = 'M' and handler->meth <> 0 and line_exists( <callparams>[ op = 'A' ] ).
      " was this an implementation for a projection action?
      job->load_root_infos( ).
      if job->root_infos[ root = stdpar-root ]-itype = cl_abap_behv_load=>c_impltype_PROJECTION.
        handler_kind = '%'.  " ... then reject STATE messages (dump)
      endif.
    endif.
    postprocess <enames> root reported job->log no_log none discard_after flavor handler_kind.
  endif.

  cl_abap_behv_aux=>g_curr_context = prev_context.
  release_data_area failed.
  release_data_area mapped.
  release_data_area reported.
  delete table busy_hdlr_instances with table key table_line = handler.

cleanup.
  cl_abap_behv_aux=>g_curr_context = prev_context.
  release_data_area failed.
  release_data_area mapped.
  release_data_area reported.
  delete table busy_hdlr_instances with table key table_line = handler.
endtry.

  " --- Merge results from implementation GROUPS
  merge_handler_results( job     = job
                         handler = handler
                         params  = params
                       ).

  if handler->kind eq 'M'.
    cl_abap_behv_detval=>exec_determinations_on_modify(
      root_entity_name = root
      log              = job->log
      for_unmanaged    = 'X' ).
  endif.
endmethod.


method CALL_INSTANCE_CONTROLLERS.

clear error_pools.

if job is initial or job->activities is initial.
  return.
endif.

job->close( exporting all_root_entities = all_root_entities
                           mock_instances    = mock_instances
                           hdlr_restriction  = hdlr_restriction ).

xtrace_triggers job 'CALL_INSTANCE_CONTROLLERS'.

GROUP_BEHV_BY_CLSS( exporting job              = job
                              collect_savers   = 'X'  " for CLEANUP registration
                    importing handler_sigs     = data(hdlr_sigs)
                              trigger_handlers = data(trig_hdlrs)
                    changing  error_pools      = error_pools ).

GET_HANDLERS_IN_ACTV_ORDER( exporting job         = job
                                      actv_trigs  = job->actv_trigs
                                      trig_hdlrs  = trig_hdlrs
                            importing handlers    = data(handlers)
                            changing  hdlr_sigs   = hdlr_sigs
                                      unhandled   = job->unhandled_activities
                                      error_pools = error_pools ).

dump_on_error_pools err.

data has_proj type sychar01.
data has_non_proj type sychar01.
loop at handlers assigning field-symbol(<hdlr>).
  " --- Params have been split for implementation GROUPS (in GET_HANDLERS_IN_ACTV_ORDER)
  "     Group results are merged directly in call below (else wouldn't work for projection)
  call_handler( job     = job
                handler = <hdlr>-handler
                params  = ref #( <hdlr>-params )
                root    = <hdlr>-root
              ).
  if <hdlr>-handler_idx in mki_proj.
    has_proj = 'X'.
  else.
    has_non_proj = 'X'.
  endif.
endloop.

if has_proj is not initial and has_non_proj is not initial.
  loop at handlers assigning <hdlr>.
  " --- merge projection local results and projection base results
  merge_handler_results( job     = job
                         handler = <hdlr>-handler
                         params  = ref #( <hdlr>-params )
                       ).
  endloop.
endif.

endmethod.


  method call_permissions.

    clear error_pools.

    if job is initial or job->activities is initial.
      return.
    endif.

    check_switches_for_permissions( job->activities ).

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " init subjobs chain and determine static feature info
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->create_init_static_sub_jobs( ).

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Global Authorization
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->create_glbl_auth_sub_jobs( ).
    if job->m_subjobs-global_authorization is not initial.
      "dispatch to global authorization sub job
      call_global_authorization(
          exporting job = job->m_subjobs-global_authorization
                    all_root_entities = all_root_entities
          importing error_pools = error_pools ).
      job->collect_glbl_auth_and_reduce( ).
    endif.

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Global Features
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->create_glbl_feat_sub_jobs( ).
    if job->m_subjobs-global_features is not initial.
      "dispatch to global feature sub job
      call_global_controllers(
          exporting job = job->m_subjobs-global_features
                    all_root_entities = all_root_entities
          importing error_pools = error_pools ).
      job->collect_glbl_feat_and_reduce( ).
    endif.

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Prepare globals for instance and merge static
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->collect_glbl_for_inst( ).

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Instance Authorization/Features
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->create_inst_auth_sub_jobs( ).
    if job->m_subjobs-instance_authorization is not initial.
      "dispatch to authority sub job
      call_authority_checks(
        exporting job = job->m_subjobs-instance_authorization
                  all_root_entities = all_root_entities
        importing error_pools = data(aerror_pools) ).

      loop at aerror_pools assigning field-symbol(<ep>).
          read table error_pools with table key table_line = <ep> transporting no fields.
          if sy-subrc ne 0.
            insert <ep> into table error_pools.
          endif.
      endloop.
    endif.
    " always collect even if there are no auth jobs,
    " there can be failed reads for master that have to be resolved
    job->collect_inst_auth( ).

    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " Instance Authorization/Features
    """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    job->create_inst_feat_sub_jobs( ).
    if job->m_subjobs-instance_features is not initial.
      "dispatch to feature sub job
      call_instance_controllers(
        exporting job = job->m_subjobs-instance_features
                  all_root_entities = all_root_entities
        importing error_pools = data(ferror_pools) ).

      loop at ferror_pools assigning <ep>.
          read table error_pools with table key table_line = <ep> transporting no fields.
          if sy-subrc ne 0.
            insert <ep> into table error_pools.
          endif.
      endloop.
    endif.
    job->collect_instance( ).

  endmethod.


method call_precheckers.
" Phase Model of Execution
"
" MODIFY (SADL see CL_RAP_BHV_PROCESSOR=>IF_RAP_EML_PROCESSOR~MODIFY)
"   GLOBAL PERMISSIOM (SADL)
"   LOCK (SADL)
"   PRECHECK (SADL)
"     PRECHECK PROJECTION
"     AUGMENTING
"       AUGM_OPS GLOBAL PERMISSION (EXECUTE before PRECHECK_BASE)
"       AUGM_OPS LOCK (EXECUTE before PRECHECK_BASE)
"     PRECHECK BASE
"       AUGM_OPS INSTANCE PERMISSION (EXECUTE after PRECHECK_BASE)
"   INSTANCE PERMISSION (SADL)
"   MODIFY  (SADL)

  clear error_pools.
  if job is initial or job->activities is initial.
    return.
  endif.

  job->close( exporting all_root_entities = all_root_entities
                        kind              = 'P'
                        mock_instances    = mock_instances
                        hdlr_restriction  = hdlr_restriction ).

  if job->behavior is initial.
    return.  " quick exit: no PRECHECK behavior exists
  endif.

  data(th) = cond t_trace_hier(
   when cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-default
   then value #(
    nest = cl_abap_behv_tracer=>tracer->trace_beg( message = text_006 procedure = 'CALL_PRECHECKERS' ) ) ).

  xtrace_triggers job 'CALL_PRECHECKERS'.

  group_behv_by_clss( exporting job              = job
                                collect_savers   = 'X'  " for CLEANUP registration
                      importing handler_sigs     = data(hdlr_sigs)
                                trigger_handlers = data(trig_hdlrs)
                      changing  error_pools      = error_pools ).
  get_handlers_in_actv_order( exporting job         = job
                                        actv_trigs  = job->actv_trigs
                                        trig_hdlrs  = trig_hdlrs
                                        kind        = 'P'
                              importing handlers    = data(handlers)
                              changing  hdlr_sigs   = hdlr_sigs
                                        unhandled   = job->unhandled_activities
                                        error_pools = error_pools ).
  dump_on_error_pools err.

  " Direct Precheck-PROJ must run before Precheck-BASE (thru generic PROJ handler),
  " so FAILED instances from the former can be removed from the params for the latter
  data(proj_hdlrs) = value tt_handler(
    for <h> in handlers where ( handler_idx in mki_proj ) ( <h> ) ).
  delete handlers where handler_idx in mki_proj.

  data(fail_log) = cond #( when proj_hdlrs is not initial
                       then cast cl_abap_behv_log( cl_abap_behv_log=>create( ) ) ).

  data(prch_job) = job.
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  " 1) call all handler for direct prechecks
  " optimization: do not call prechecks in local mode but if extensible
  if job->m_in_local_mode = abap_true.
    " build array with extensible info for all activities
    data(actv_ext_array) = ` `. " index 0 does not exist always space
    loop at job->activities assigning field-symbol(<actv>).
      data(info) = cl_abap_behv_load=>get_info_from_cache( <actv>-entity_name ).
      actv_ext_array &&= cond #( when info->extensible is not initial then `X` else ` ` ).
    endloop.
    loop at handlers assigning field-symbol(<hdlr>).
      " remove parameters for extensible entities
      loop at <hdlr>-params assigning field-symbol(<param>).
        check actv_ext_array+<param>-actv_idx(1) <> `X`.
        delete <hdlr>-params index sy-tabix.
      endloop.
      check <hdlr>-params is not initial.
      call_handler( job      = prch_job
                    handler  = <hdlr>-handler
                    params   = ref #( <hdlr>-params )
                    root     = <hdlr>-root
                    " if this is Precheck-PROJ and a Precheck-BASE handler follows,
                    " record FAILED entries in extra log for their removal (see above):
                    fail_log = cond #(
                     when line_exists( proj_hdlrs[ root = <hdlr>-root ] )
                     then fail_log ) ).
    endloop.
  else. " no local mode
    loop at handlers assigning <hdlr>.
      call_handler( job      = prch_job
                    handler  = <hdlr>-handler
                    params   = ref #( <hdlr>-params )
                    root     = <hdlr>-root
                    " if this is Precheck-PROJ and a Precheck-BASE handler follows,
                    " record FAILED entries in extra log for their removal (see above):
                    fail_log = cond #(
                     when line_exists( proj_hdlrs[ root = <hdlr>-root ] )
                     then fail_log ) ).
    endloop.
  endif.

  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  " 2) call all augmenting handlers
  loop at proj_hdlrs assigning <hdlr>.
    data(proj_hdlr) = cast cl_abap_behv_handler_proj( <hdlr>-handler ).
    if fail_log is not initial
       and line_exists( fail_log->failed_entities[ root_name = <hdlr>-root ] ).
      " FAIL_LOG (filled by previous Precheck-PROJ, see below) contains entities
      " for current root => clone job and reduce activities
      prch_job = cl_abap_behv_job=>create( log = job->log attrs_from = job ).
      data(reduced_activities) = job->activities.
      proj_hdlr->remove_faileds_from_activities(
       exporting failed_entities = fail_log->failed_entities
                 clone_instances = 'X'  " do not modify instances in original job
       changing  activities      = reduced_activities ).
      if reduced_activities is initial.
        continue.  " nothing left to do
      endif.
      prch_job->add_changes_tab( reduced_activities ).
      " job attributes needed for PREPARE (and Augment)
      prch_job->augm_behavior = job->augm_behavior.
      prch_job->m_content     = job->m_content.
    else.
      prch_job = job.
    endif.
    " (AUGM_in_PRCH): Projection handler must be PREPAREd immediately before call, not
    " in GET_HANDLER as usual, because PREPARE may issue Augment (for the Precheck-BASE)
    assert proj_hdlr->m_proj_root = <hdlr>-root.
    proj_hdlr->call_augment( prch_job ).

  endloop.

  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
  " 3) call all handler for base prechecks
  loop at proj_hdlrs assigning <hdlr>.
    proj_hdlr = cast cl_abap_behv_handler_proj( <hdlr>-handler ).
    if fail_log is not initial
     and line_exists( fail_log->failed_entities[ root_name = <hdlr>-root ] ).
      " FAIL_LOG (filled by previous Precheck-PROJ, see below) contains entities
      " for current root => clone job and reduce activities
      prch_job = cl_abap_behv_job=>create( log = job->log attrs_from = job ).
      reduced_activities = job->activities.
      proj_hdlr->remove_faileds_from_activities(
       exporting failed_entities = fail_log->failed_entities
                 clone_instances = 'X'  " do not modify instances in original job
       changing  activities      = reduced_activities ).
      if reduced_activities is initial.
        continue.  " nothing left to do
      endif.
      prch_job->add_changes_tab( reduced_activities ).
      " job attributes needed for PREPARE (and Augment)
      prch_job->augm_behavior = job->augm_behavior.
      prch_job->m_content     = job->m_content.
    else.
      prch_job = job.
    endif.
    " (AUGM_in_PRCH): Projection handler must be PREPAREd immediately before call, not
    " in GET_HANDLER as usual, because PREPARE may issue Augment (for the Precheck-BASE)
    assert proj_hdlr->m_proj_root = <hdlr>-root.
    proj_hdlr->prepare(
      job      = prch_job
      kind     = cl_abap_behv_ctrl=>op-precheck ).
    proj_hdlr->call_precheck( prch_job ).

  endloop.

  xtrace_end_hier th.

endmethod.


method CALL_READERS.

clear error_pools.

if job is initial or job->activities is initial.
  return.
endif.

" === Determine triggers and retrieve behavior for all activities in job
job->close( exporting all_root_entities = all_root_entities
                      mock_instances    = mock_instances
                      hdlr_restriction  = hdlr_restriction ).

if job->m_internal is initial. " %_INTERNAL: suppress trace
  xtrace_triggers job 'CALL_READERS'.
endif.

" === Build 'method signatures' for all relevant handlers; map triggers to handlers (by index)
GROUP_BEHV_BY_CLSS( exporting job              = job
                              collect_savers   = 'X'  " for CLEANUP registration
                    importing handler_sigs     = data(hdlr_sigs)
                              trigger_handlers = data(trig_hdlrs)
                    changing  error_pools      = error_pools ).

GET_HANDLERS_IN_ACTV_ORDER( exporting job         = job
                                      actv_trigs  = job->actv_trigs
                                      trig_hdlrs  = trig_hdlrs
                            importing handlers    = data(handlers)
                            changing  hdlr_sigs   = hdlr_sigs
                                      unhandled   = job->unhandled_activities
                                      error_pools = error_pools ).

dump_on_error_pools err.

" === Call handlers in sequence
loop at handlers assigning field-symbol(<hdlr>).
  call_handler( job     = job
                handler = <hdlr>-handler
                params  = ref #( <hdlr>-params )
                root    = <hdlr>-root
              ).
endloop.

endmethod.


method CALL_SAVER.

field-symbols <area_failed>   type t_data_area.
field-symbols <failed>        type data.
field-symbols <area_mapped>   type t_data_area.
field-symbols <mapped>        type data.
field-symbols <area_reported> type t_data_area.
field-symbols <reported>      type data.
field-symbols <enames>        type data.

data proj_saver               type ref to cl_abap_behv_saver_proj.
data discard_mapped           type sychar01 value 'X'.
data discard_failed           type sychar01 value 'X'.
data discard_reported         type sychar01 value 'X'.
data former_saver             type ref to cl_abap_behavior_saver.

define chkpre.
  if saver->meth-&1 = not_implemented.
    is_void = 'X'.
    return.  " phase not implemented
  endif.
  saver->in_phase = phase.
  if saver is instance of cl_abap_behv_saver_proj.
    proj_saver ?= saver.
    proj_saver->log = log.
  endif.
end-of-definition.

define clean_up.
  release_data_area failed.
  release_data_area mapped.
  release_data_area reported.
  if proj_saver is not initial.  clear proj_saver->log.  endif.
end-of-definition.

clear: is_void, direct_failed, direct_mapped, direct_reported.

data(direct_response) = xsdbool(   direct_failed   is supplied
                                or direct_mapped   is supplied
                                or direct_reported is supplied ).

try.

  if get_saver_response( exporting saver    = saver
                                   phase    = phase
                         importing failed   = direct_failed
                                   mapped   = direct_mapped
                                   reported = direct_reported ).
* --- The saver has already run (this phase)
*   - It does not run again.
*   - Its responses are not logged again.
*   - If it is a base saver of a projection, its previously
*     saved responses are returned directly for mapping.
    return.
  endif.

  data(th) = cond t_trace_hier(
   when cl_abap_behv_tracer=>xtrace_level >= cl_abap_behv_tracer=>c_xtrace-essential
   then value #(
    let _msg = |{ text_004 } ({ phase }) { objectdescr( saver ) }| in ##TYPE
     msg  = _msg
     nest = cl_abap_behv_tracer=>tracer->trace_beg( trace_level = cl_abap_behv_tracer=>c_xtrace-essential
     message = _msg
     procedure = 'CALL_SAVER'
     properties = value #( ( name = 'ROOT'  value = root ) ( name = 'PHASE' value = phase ) ) ) ) ).

  " --- The saver hasn't run yet (this phase). Run it now

  system-call debugger set system path suspend.  "#EC CI_SYSTEMCALL

  case phase.

    when if_abap_behv=>phases-FINALIZE.
      chkpre FINALIZE.  " may exit
      get_data_area_late FAILED   root.  " assign <FAILED>
      get_data_area_late REPORTED root.  " assign <REPORTED>
      former_saver = curr_saver.
      curr_saver = saver.
      exec_beg.
      saver->FINALIZE( changing
         FAILED   = <failed>
         REPORTED = <reported>
      ).
      exec_end.
      curr_saver = former_saver.

    when if_abap_behv=>phases-CLEANUP_FINALIZE.
      chkpre CLEANUP_FINALIZE.  " may exit
      exec_beg.
      saver->CLEANUP_FINALIZE( ).
      exec_end.

    when if_abap_behv=>phases-CHECK_BEFORE_SAVE.
      chkpre CHECK_BEFORE_SAVE.  " may exit
      get_data_area_late FAILED   root.
      get_data_area_late REPORTED root.
      exec_beg.
      saver->CHECK_BEFORE_SAVE( changing
        FAILED   = <failed>
        REPORTED = <reported>
      ).
      exec_end.

    when if_abap_behv=>phases-ADJUST_NUMBERS.
      chkpre ADJUST_NUMBERS.  " may exit
      get_data_area_late MAPPED   root.
      get_data_area_late FAILED   root.
      get_data_area_late REPORTED root.
      exec_beg.
      saver->ADJUST_NUMBERS( changing
        MAPPED   = <mapped>
        REPORTED = <reported>
        FAILED   = <failed>
      ).
      exec_end.

    when if_abap_behv=>phases-SAVE.
      chkpre SAVE.  " continues (SAVE is mandatory)
      get_data_area_late FAILED   root.
      get_data_area_late REPORTED root.
      exec_beg.
      saver->SAVE( changing
        FAILED   = <failed>
        REPORTED = <reported>
      ).
      exec_end.

    when if_abap_behv=>phases-CLEANUP.
      chkpre CLEANUP.  " may exit
      exec_beg.
      saver->CLEANUP( ).
      exec_end.

  endcase.

  system-call debugger set system path resume.  "#EC CI_SYSTEMCALL

  if th is not initial.
    cl_abap_behv_tracer=>tracer->trace_end( hierarchy_number = th-nest  message = |<{ th-msg }|  properties = value #(
     let _props = value if_sxt_types=>ty_property_tab(
      ( name = 'FAILED'   value = |{ cond #( when <failed>   is assigned then linecount( <failed> ) ) }| )
      ( name = 'MAPPED'   value = |{ cond #( when <mapped>   is assigned then linecount( <mapped> ) ) }| )
      ( name = 'REPORTED' value = |{ cond #( when <reported> is assigned then linecount( <reported> ) ) }| ) )
     in for <_p> in _props where ( value <> '0' ) ( <_p> ) ) ).
  endif.

  if direct_response is not initial.
    " --- Remember responses (in case of multiple consumers)
    "     Even empty responses, to avoid multiple invocation
    " This might be done *always*; then in the case of BASE running before PROJ (if BASE
    " was first directly accessed in request), PROJ would also get the PROJ responses.
    " The cost would be: unnecessary caching in case no PROJ consumer follows.
    set_saver_response( saver    = saver
                        phase    = phase
                        failed   = cond #( when <area_failed>   is assigned then <area_failed>-ref )
                        mapped   = cond #( when <area_mapped>   is assigned then <area_mapped>-ref )
                        reported = cond #( when <area_reported> is assigned then <area_reported>-ref )
                      ).
  "endif.
  "if direct_response is not initial.
    " --- Direct return of responses (projection saver will map them)
    if direct_failed is supplied and <area_failed> is assigned.
      direct_failed = <area_failed>-ref.
      discard_failed = ' '.
    endif.
    if direct_mapped is supplied and <area_mapped> is assigned.
      direct_mapped = <area_mapped>-ref.
      discard_mapped = ' '.
    endif.
    if direct_reported is supplied and <area_reported> is assigned.
      direct_reported = <area_reported>-ref.
      discard_reported = ' '.
    endif.
    " --- But don't skip logging below (must log at least BASE-MAPPED in addition to PROJ-MAPPED)

  endif.


  " --- Postprocessing (logging) ---

  constants smsg_log type ref to if_abap_behv_log value is initial.

  " Extra log object for EML COMMIT exists?
  set_eml_commit_log curr_log root log.

  data flavor type if_abap_behv_log=>t_flavor value if_abap_behv_log=>unspecific.
  if direct_response is not initial.
    flavor = if_abap_behv_log=>BASE.
  elseif saver is instance of CL_ABAP_BEHV_SAVER_PROJ.
    flavor = if_abap_behv_log=>PROJECTION.
  endif.

  if <failed> is assigned and <failed> is not initial.
    postprocess <enames> root failed log curr_log phase discard_failed flavor ''.
  endif.

  if <mapped> is assigned and <mapped> is not initial.
    postprocess <enames> root mapped log no_log phase discard_mapped flavor ''.
    " [[[ kludge was here to also log BASE in PROJECTION job ]]]
  endif.

  if <reported> is assigned and <reported> is not initial.
    postprocess <enames> root reported log curr_log phase discard_reported flavor ''.
    " REMOVED_REPORTED entities to be processed indirectly by ADD_REMOVED_REPORTED below
    loop at removed_reported assigning field-symbol(<rr>).
      insert <rr> into table removed_entities.
    endloop.
  endif.

  if <reported> is assigned and
     saver is instance of cl_abap_behv_saver_proj.
    " calls with empty instance table are needed for state message handling
    " this must be after logging of FAILED for projection (above)
    cast cl_abap_behv_saver_proj(
     saver )->ADD_REMOVED_REPORTED( log      = log
                                    reported = <reported> ).
  endif.

  clean_up.

cleanup.
  clean_up.
endtry.

endmethod.


method CHECK_COMPATIBLE_FIELDS
  by kernel module ab_km_behv_check_compatible_fields ignore.
endmethod.


method CHECK_TEST_DOUBLE_ALLOWED.

if cond i( let _st = cl_abap_get_call_stack=>format_call_stack_with_struct( cl_abap_get_call_stack=>get_call_stack( ) ) in
            when line_exists( _st[ progname = 'CL_AUNIT_TEST_CLASS===========CP' ] ) then 42
         ) <> 42.
  raise shortdump type cx_abap_behv_runtime_error message e028
        exporting tadir_key = cl_abap_behv_ctrl=>get_caller( ).
endif.

endmethod.


method CLASS_CONSTRUCTOR.

types t_c80 type c length 80.

data ex    type t_exempt.
data exval type t_exempt-x.
data src   type standard table of t_c80 with empty key.


mki_proj = value #( sign = 'I' option = 'EQ'
            ( low = mki-projection ) ( low = mki-proj_d_csp ) ( low = mki-proj_d_bsp ) ).

mki_proj_draft = value #( sign = 'I' option = 'EQ'
            ( low = mki-proj_d_csp ) ( low = mki-proj_d_bsp ) ).

mki_draft = value #( sign = 'I' option = 'EQ'
            ( low = mki-csp_draft ) ( low = mki-bsp_draft )
            ( low = mki-proj_d_csp ) ( low = mki-proj_d_bsp )
            option = 'LT'
            ( low = -31768 ) ).

assert area_is_set = |{ CL_ABAP_BEHV=>CO_TECHFIELD_NAME-STATE_AREA } IS NOT INITIAL| ##BOOL_OK.


g_extab = value #(
  ( name = 'R_FLDLOGSPROCESSRECEIPTSTP'     x = ex_cd )     " 783/2102
  ( name = 'R_SCHEDGAGRMTHDRTP'             x = ex_cd )     " 784/2105
  ( name = 'R_PURCHASECONTRACTTP'           x = ex_cd )     " 784/2105
  ( name = 'I_PURCHASECONTRACTTP'           x = ex_cd )     " 784/2105
  ( name = 'I_FLDLOGSCONTAINERLISTTP'       x = ex_cd bit-or ex_cs bit-or ex_cfibu )  " 784/2105, 785/2108
  ( name = 'C_FLDLOGSCONTAINERLIST'         x = ex_cd bit-or ex_cs )  " 784/2105
  ( name = 'R_SALESORDERTP'                 x = ex_cd bit-or ex_cs )  " 785/2108
  ( name = 'C_SALESORDERMANAGE'             x = ex_cs )
  ( name = 'R_SALESORDERREQUESTTP'          x = ex_cs bit-or ex_cfiut )
  ( name = 'I_PRODUCTIONORDERTP'            x = ex_cs )
  ( name = 'R_PRODUCTIONORDERTP'            x = ex_cs )     " 784/2105
  ( name = 'R_MAINTENANCETASKLISTTP'        x = ex_cs )     " 784/2105
  ( name = 'I_FLDLOGSSTOCKTP'               x = ex_cs )     " 785/2108
  ( name = 'R_SUPPLIERINVOICETP'            x = ex_cs bit-or ex_sr )  " 786/2111
" ( name = 'A_ENTERPRISEPROJECT'            x = ex_cfiut )  " removed RC 2021-05
" ( name = 'I_ENTERPRISEPROJECTTP'          x = ex_cfiut )  " removed RC 2021-05
" ( name = 'A_ENTERPRISEPROJECT_2'          x = ex_cfiut )  " removed RC 2021-05
" ( name = 'I_ENTERPRISEPROJECTTP_2'        x = ex_cfiut )  " removed RC 2021-05
" ( name = 'R_DISPUTECASETP'                x = ex_cfiut )  " 785/2108, removed RC 2021-05
" ( name = 'A_PRODUCTIONORDERCONF_2'        x = ex_cfiut )  " removed RC 2020-11
" ( name = 'A_PROCORDCONFIRMATION_2'        x = ex_cfiut )  " removed RC 2020-11
  ( name = 'CDR_I_SCOPE_MAIN_U'             x = ex_sr )     " 785/2108
  ( name = 'CDR_I_PACKAGE_U'                x = ex_sr )     " 785/2108
  ( name = 'CTE_I_STL_PJ_LIST'              x = ex_sr )     " 785/2108
" ( name = 'R_MAINTENANCEORDERTP'           x = ex_sr )     " 785/2108, removed RC 2021-05
" ( name = 'R_MAINTORDERCONFIRMATIONTP'     x = ex_sr )     " 785/2108, removed RC 2021-07
" ( name = 'R_ORGANIZATIONALCHANGETP'       x = ex_sr )     " 785/2108, removed RC 2021-04
  ( name = 'R_PHYSICALINVENTORYDOCUMENTTP'  x = ex_sr )     " 785/2108
" ( name = 'R_PLANNEDORDERTP'               x = ex_sr )     " 785/2108, removed I068107 2021-05
  ( name = 'R_REPETITIVEMFGCONFIRMATIONTP'  x = ex_sr )     " 785/2108
" ( name = 'I_INHOUSEREPAIRTP'              x = ex_sr )     " 785/2108, removed RC 2021-05
" ( name = 'I_CUSTOMIZINGREQUESTS'          x = ex_sr )     " 785/2108, removed I335334 2021-07
  ( name = 'A_EQUIPMENT'                    x = ex_sr )     " 785/2108 (https://support.wdf.sap.corp/sap/support/message/2180192328)
  ( name = 'C_FRTORDEXECUTION'              x = ex_cfibu )  " 785/2108
  ( name = 'C_FRTORDGENDATABASICFACTS'      x = ex_cfibu )  " 785/2108
  ( name = 'C_PAYMENTCOCKPITSUSPCASESTATUS' x = ex_cfibu )  " 785/2108
" ( name = 'R_LSTMIPROCESSMAINTENANCETP'    x = ex_cfibu )  " 785/2108, removed D052984 2021-05
  ( name = 'R_OUTPUTREQUESTTP'              x = ex_cfibu )  " 785/2108
  ( name = 'C_FRTORDMANAGEMENT'             x = ex_cfibu )  " 785/2108 (https://support.wdf.sap.corp/sap/support/message/2180192328)
  ( name = 'R_FLDLOGSPROCESSSHIPMENTITEMTP' x = ex_cd bit-or ex_cs )  " 786/2111
  ( name = 'R_OPERATINGCHARTOFACCOUNTSTP'   x = ex_sr )     " 786/2111
).

read report 'SABP_BEHV_EXEMPTIONS' into src.

loop at src assigning field-symbol(<src>).
  check <src>(1) = '*'.
  if <src>+1(1) = '.'.  " section start
    if <src>+2 = 'CD'.
      exval = ex_cd.
    elseif <src>+2 = 'CS'.
      exval = ex_cs.
    elseif <src>+2 = 'CFIUT'.
      exval = ex_cfiut.
    elseif <src>+2 = 'SR'.
      exval = ex_sr.
    elseif <src>+2 = 'CFIBU'.
      exval = ex_cfibu.
    elseif <src>+2 = 'LF'.
      exval = ex_lf.
    elseif <src>+2 = 'CQD'.
      exval = ex_cqd.
    elseif <src>+2 = 'STS'.
      exval = ex_sts.
    elseif <src>+2 = 'SNC'.
      exval = ex_snc.
    elseif <src>+2 = 'TTX'.
      exval = ex_ttx.
    else.
      clear exval.
      continue.  " unknown section
    endif.
  elseif <src>(2) = '**'.
    continue.  " comment line, ignore
  elseif exval is not initial.
    ex-name = <src>+1.
    data(nl) = strlen( ex-name ).
    if ex-name(nl) ca ` `.
      ex-name = ex-name(sy-fdpos).  " trailing information, ignored
    endif.
    if ex-name(1) = '-'.  " remove default entry
      shift ex-name by 1 places left.
      clear ex-x.  " value to be removed
    else.
      ex-x = exval.  " value to be added
    endif.
    assign g_extab[ name = ex-name ] to field-symbol(<ex>).
    if sy-subrc <> 0.
      if ex-x is initial.
        continue.
      endif.
      insert ex into table g_extab assigning <ex>.
    endif.
    if ex-x is not initial.
      <ex>-x = <ex>-x bit-or ex-x.
    else.  " remove entry
      <ex>-x = <ex>-x  bit-and bit-not exval.
      if <ex>-x is initial.
        delete table g_extab with table key name = ex-name.
      endif.
    endif.
  endif.
endloop.

call 'BEHV_EXEC' id 'OP' field 12 id 'TAB' field g_extab.  "#EC CI_CCALL

*cl_abap_behv_tracer=>tracer = new cl_abap_behv_tracer( ).
*cl_abap_behv_tracer=>tracer->get_trace_level( ).

endmethod.


method END_SAVER_COLLECTION.

clear saver_collector.

endmethod.


method EXECUTE_COMMIT.

data intf_exist type sychar01.
data real_names type tt_real_name.

field-symbols <real>  type t_real_name.
field-symbols <resp>  type t_response.
field-symbols <dresp> type t_response.

field-symbols <area_failed>   type t_data_area.
field-symbols <failed>        type data.
field-symbols <area_reported> type t_data_area.
field-symbols <reported>      type data.


system-call debugger set system path on.  "#EC CI_SYSTEMCALL

if curr_responses        is not initial or
   curr_responses_genlog is not initial.
  " Since COMMIT is forbidden in RAP handlers, this situation
  " is likely not due a "COMMIT within COMMIT", but rather a
  " preceding COMMIT that ended unexpectedly
  clear: curr_responses, curr_responses_genlog.
  "raise shortdump type cx_abap_behv_runtime_error
  "  message e015.
endif.

if scope = 'E'.
  get_eml_processor.
  eml_processor->close_save( ).
  rc = 0.
  return.
endif.

" --- Determine base root names if interfaces are included in responses
define GET_REAL_NAMES.
  loop at &1 assigning field-symbol(<&1_line>).
    cl_abap_behv_load=>get_load( exporting entity = &2 importing head = data(hd_&1) ).
    if hd_&1-impltype = cl_abap_behv_load=>c_impltype_INTERFACE.
      data(rela_&1) = cl_abap_behv_load=>get_relation(
                       source_entity = &2
                       kind          = cl_abap_behv_load=>c_relation_base
                       original_root = &2 ).
      insert value #( orig = &2 real = rela_&1->target_entity ) into table real_names.
      intf_exist = 'X'.
    else.
      insert value #( orig = &2 real = &2 ) into table real_names.
    endif.
  endloop.
end-of-definition.


" --- Prepare LOG object(s) to be used in CALL_SAVER
if dynamic is not initial.
  " --- Dynamic COMMIT: One generic log
  " If INTFs are involved and dynamic EML supplies non-empty ROOT_NAMES:
  " - Requesting an INTF yields mapping of BASE responses.
  " - Requesting a BASE yields BASE responses.
  " - Both at once is possible. Several INTFs on same BASE are also possible.
  " If requested ROOT_NAMES is empty, but at least one Modify was done on an
  "   INTF, then responses are returned wrt. INTFs. Otherwise, BASE responses
  "   would be returned, which is unnatural.
  if root_names is not initial.
    GET_REAL_NAMES root_names <root_names_line>.
  else.
    real_names = roots_modified.
    loop at roots_modified assigning <real>.
      if <real>-real <> <real>-orig.  intf_exist = 'X'. exit.  endif.
    endloop.
    if intf_exist is initial.
      clear real_names.  " no INTFs used -> no filtering at all
    endif.
  endif.
  assert lines( responses ) = 1.
  assign responses[ 1 ] to <dresp>.
  if intf_exist is initial.
    " no interfaces requested; no interfaces will appear in responses
    curr_responses_genlog = cl_abap_behv_log=>create_for_eml(
      roots        = root_names
      dynamic      = 'X'
      ref_failed   = <dresp>-r_failed
      ref_reported = <dresp>-r_reported ).
  else.
    " at least one interface requested; mapping of responses required (below)
    curr_responses_genlog = cl_abap_behv_log=>create_for_eml(
      roots        = value #( for groups <g> of <n> in real_names group by <n>-real ( <g> ) )
      dynamic      = 'X' ).
  endif.

else.
  " --- Static COMMIT: Separate log per root
  GET_REAL_NAMES responses <responses_line>-rootname.
  loop at responses assigning <resp>.
    assign real_names[ orig = <resp>-rootname ] to <real>.
    if <resp>-rootname = <real>-real.
      insert value #( base <resp>
                      log = cl_abap_behv_log=>create_for_eml(
                              root         = <resp>-rootname
                              ref_failed   = <resp>-r_failed
                              ref_reported = <resp>-r_reported ) ) into table curr_responses.
    else.
      " this is an interface; mapping of responses required (below)
      get_data_area_late FAILED   <real>-real.  " assign <FAILED>
      get_data_area_late REPORTED <real>-real.  " assign <REPORTED>
      data(r_failed)   = ref #( <failed> ).
      data(r_reported) = ref #( <reported> ).
      insert value #( rootname   = <real>-real
                      r_failed   = r_failed
                      r_reported = r_reported
                      log = cl_abap_behv_log=>create_for_eml(
                              root         = <real>-real
                              ref_failed   = r_failed
                              ref_reported = r_reported ) ) into table curr_responses.
    endif.
  endloop.
endif.


xtrace_beg_hier_eml th 'Commit' 'EXECUTE_COMMIT' dynamic 0 ##NO_TEXT.


" === Pause transaction control
cl_abap_behv_transaction_ctrl=>pause( ).


" === Call transaction manager
get_eml_processor.

data failed type abap_bool.
data failed_late type abap_bool.
if partial = 'S'.
  eml_processor->simulate_save(
    importing ev_failed = failed ).
else.
  eml_processor->save(
    importing ev_failed      = failed
              ev_failed_late = failed_late ).
endif.

" --- Add state messages
if dynamic is not initial.
  eml_processor->add_state_messages( iv_root_name = value #( )
                                     io_log = curr_responses_genlog ).
else.
  loop at curr_responses assigning <resp>.
    eml_processor->add_state_messages( iv_root_name = <resp>-rootname
                                       io_log       = <resp>-log ).
  endloop.
endif.


" === Map responses from base to interfaces
if intf_exist is not initial.

  if dynamic is not initial.
    if <dresp>-r_failed is bound.
      assign <dresp>-r_failed->* to field-symbol(<orig_failed>).
      cl_abap_behv_saver_proj=>TRANSFER_RESP_TAB_TO_PROJ(
       exporting op            = cl_abap_behvdescr=>op_FAILED_late
                 base_entities = curr_responses_genlog->FAILED_entities
                 real_names    = real_names
       changing  proj_entities = <orig_failed> ).
    endif.
    if <dresp>-r_reported is bound.
      assign <dresp>-r_reported->* to field-symbol(<orig_reported>).
      cl_abap_behv_saver_proj=>TRANSFER_RESP_TAB_TO_PROJ(
       exporting op            = cl_abap_behvdescr=>op_REPORTED_late
                 base_entities = curr_responses_genlog->REPORTED_entities
                 real_names    = real_names
       changing  proj_entities = <orig_reported> ).
    endif.

  else.
    loop at real_names assigning <real>.
      check <real>-orig <> <real>-real.
      assign responses[ rootname = <real>-orig ] to <resp>.
      if <resp>-r_failed is initial and <resp>-r_reported is initial.
        continue.  " EML didn't request responses for this interface
      endif.
      assign curr_responses[ rootname = <real>-real ] to field-symbol(<base_resp>).
      data(intf_log) = cl_abap_behv_log=>create_for_eml(
                         root         = <resp>-rootname
                         ref_failed   = <resp>-r_failed
                         ref_reported = <resp>-r_reported ).
      cl_abap_behv_saver_proj=>TRANSFER_RESP_TO_PROJ_LOG( kind = if_abap_behv_log=>FAILED_LATE
        proj_root     = <real>-orig
        base_root     = <real>-real
        proj_response = <resp>-r_FAILED
        base_response = <base_resp>-r_FAILED
        log           = intf_log ).
      cl_abap_behv_saver_proj=>TRANSFER_RESP_TO_PROJ_LOG( kind = if_abap_behv_log=>REPORTED_LATE
        proj_root     = <real>-orig
        base_root     = <real>-real
        proj_response = <resp>-R_REPORTED
        base_response = <base_resp>-R_REPORTED
        log           = intf_log ).
    endloop.
  endif.
endif.

if scope is initial.
" --- release EML processor resources
  eml_processor->close_save( ).
endif.
" ===

" === Resume or stop transaction control
if partial = 'S' or failed is not initial.
  cl_abap_behv_transaction_ctrl=>resume( ).
else.
  cl_abap_behv_transaction_ctrl=>stop( ).
endif.


clear: curr_responses, curr_responses_genlog.
clear roots_modified.

if failed_late is not initial.
  rc = 8.
elseif failed is not initial.
  rc = 4.
else.
  rc = 0.
endif.

xtrace_end_hier th.

endmethod.


method EXECUTE_CONVERT_PRE.

data pid_null type abp_behv_pid.

field-symbols <pid> type ABP_BEHV_PID.
field-symbols <tmp> type DATA.


system-call debugger set system path on.  "#EC CI_SYSTEMCALL

data(real_entity) = entity.

cl_abap_behv_load=>get_load( exporting entity = entity importing head = data(hd) ).
if hd-impltype = cl_abap_behv_load=>c_impltype_INTERFACE.
  " key conversion for INTF requested: must ask registry with BASE entity
  data(rela) = cl_abap_behv_load=>get_relation( source_entity = entity
                                                kind          = cl_abap_behv_load=>c_relation_base ).
  if rela is not initial.
    real_entity = rela->target_entity.
  endif.
endif.

get_eml_converter.

bind_key KEY real_entity.  " binds <KEY>; throws for wrong type of KEY

if mode = ' '.
  " --- statically unknown type of PREKEY
  check_compatible_fields( exporting field1 = prekey field2 = key importing rc = _conv_rc ).
  if _conv_rc = 0.
    mode = 'T'.
  else.
    describe field prekey type data(tpk) components data(cpk) length data(lpk) in byte mode.
    if tpk = 'X' and lpk = 16.
      mode = 'X'.  " PREKEY is (most likely) PID
    elseif tpk na 'uw'.
      mode = 'T'.  " PREKEY must be component 1 of KEY
    elseif cpk <> 2.
      mode = 'T'.  " bind_key will dump
    else.
      mode = 'S'.
    endif.
  endif.
endif.

if mode = 'T'.
  " --- PREKEY is TMP or its single component
  bind_key PREKEY real_entity.  " binds <PREKEY>; throws for wrong type of PREKEY
  assign pid_null to <pid>.
  assign <prekey> to <tmp>.

elseif mode = 'S'.
  " --- PREKEY is %PRE structure
  assign component 1 of structure prekey to <pid>.
  assign component 2 of structure prekey to <tmp>.

else. "if mode = 'X'.
  " --- PREKEY is PID
  assign prekey     to <pid>.
  assign prekey_dyn to <tmp>.
endif.


data mocked type i value 0.

if mock_entities is not initial and
 cast IF_ABAP_BEHAVIOR_TESTDOUBLE(
   let _rn = value #( mock_entities[ entity_name = real_entity ]-root_name default ' ?' )
       _mi = ref #( mock_instances[ root_name = _rn ] optional )
    in cond #( when _mi is not initial
                and _mi->has_convert <> 'N' then _mi->object ) ) is bound .
  try.
    assign mock_instances[ root_name = mock_entities[ entity_name = real_entity ]-root_name ] to field-symbol(<mi>).
    <mi>-object->convert_preliminary_key( exporting entity_name = real_entity
                                                    pid         = <pid>
                                                    tmp         = <tmp>
                                           changing key         = <key> ).
    mocked = 1.  <mi>-has_convert = 'Y'.
  catch cx_sy_dyn_call_illegal_method.
    mocked = 0.  <mi>-has_convert = 'N'.
  endtry.
endif.

if mocked = 0.
  try.
    eml_converter->convert_preliminary_key(
      exporting iv_entity   = real_entity
                iv_pid      = <pid>
                is_temp_key = <tmp>
       changing cs_key      = <key> ).
  catch cx_rap_invalid_preliminary_key into data(exc).
    raise shortdump type cx_abap_behv_runtime_error exporting previous = exc.
  endtry.
endif.

if <key_comp1> is assigned.
  key_dyn = <key_comp1>.
endif.

endmethod.


method execute_global_controllers.

  data log type ref to cl_abap_behv_log.

  system-call debugger set system path on.  "#EC CI_SYSTEMCALL

  xtrace_beg_hier_eml th 'Global Features' 'EXECUTE_GLOBAL_CONTROLLERS' dynamic 0 ##NO_TEXT.

  if keep_log is initial.
*  if failed   is supplied or
*     reported is supplied .
*    " ==== clear EML response fields
*    clear failed.
*    clear reported.
*    " ==== create LOG object for transfer to EML response fields
*    log = cl_abap_behv_log=>create_for_eml(
*          exporting
*            root         = root
*            ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
*            ref_reported = cond #( when reported is supplied then ref data( reported ) )
*            dynamic      = dynamic
*          ).
*  endif.

    job->log = log.
  endif.

  data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
  cl_abap_behv_job_base=>curr_eml_job = job.

  job->disentangle( importing entangled_refs = data(erefs) ).

  "get_eml_processor.
  "eml_processor->feature_check( io_fjob  = job ).
  cl_abap_behv_ctrl=>call_global_controllers( job ).

  job->entangle( erefs ).

  cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.

  xtrace_end_hier th.

endmethod.


method execute_instance_controllers.

data log type ref to cl_abap_behv_log.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

xtrace_beg_hier_eml th 'Instance Features' 'EXECUTE_INSTANCE_CONTROLLERS' dynamic 0 ##NO_TEXT.

if keep_log is initial.
  if failed   is supplied or
     reported is supplied .
    " ==== clear EML response fields
    clear failed.
    clear reported.
    " ==== create LOG object for transfer to EML response fields
    log = cl_abap_behv_log=>create_for_eml(
          exporting
            root         = root
            ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
            ref_reported = cond #( when reported is supplied then ref data( reported ) )
            dynamic      = dynamic
          ).
  endif.

  job->log = log.
endif.

data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
cl_abap_behv_job_base=>curr_eml_job = job.

job->disentangle( importing entangled_refs = data(erefs) ).

get_eml_processor.
eml_processor->feature_check( io_fjob  = job ).

job->entangle( erefs ).

cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.

xtrace_end_hier th.

endmethod.


method EXECUTE_LOCK.

data log type ref to cl_abap_behv_log.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

xtrace_beg_hier_eml th 'Lock' 'EXECUTE_LOCK' dynamic 0 ##NO_TEXT.

if failed   is supplied or
   reported is supplied .
  " ==== clear EML response fields
  clear failed.
  clear reported.
  " ==== create LOG object for transfer to EML response fields
  log = cl_abap_behv_log=>create_for_eml(
        exporting
          root         = root
          ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
          ref_reported = cond #( when reported is supplied then ref data( reported ) )
          dynamic      = dynamic
        ).
endif.

job->log = log.

switch_intf_base 'L'.

eml_call_pre.

data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
cl_abap_behv_job_base=>curr_eml_job = job.

job->disentangle( ).

get_eml_processor.
eml_processor->lock( job ).

switch_base_intf 'L'.

cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.

eml_call_post.

xtrace_end_hier th.

endmethod.


method EXECUTE_MODIFY.

data log type ref to cl_abap_behv_log.

if curr_proj_hdlr is not initial.
  curr_proj_hdlr->add_augment_activities( changing activities = job->activities  ).
  return.
endif.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

if job->m_internal is initial.
  xtrace_beg_hier_eml th 'Modify' 'EXECUTE_MODIFY' dynamic internal ##NO_TEXT.
endif.

if failed   is supplied or
   mapped   is supplied or
   reported is supplied .
  " ==== clear EML response fields
  clear failed.
  clear mapped.
  clear reported.
  " ==== create LOG object for transfer to EML response fields
  log = cl_abap_behv_log=>create_for_eml(
        exporting
          root         = root
          ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
          ref_mapped   = cond #( when mapped   is supplied then ref data( mapped ) )
          ref_reported = cond #( when reported is supplied then ref data( reported ) )
          dynamic      = dynamic
        ).
endif.

job->log = log.

switch_intf_base 'M'.

if intf_root is not initial.
  insert value #( orig = intf_root
                  real = cl_abap_behv_load=>get_relation( source_entity = intf_root
                           kind = cl_abap_behv_load=>c_relation_base )->target_entity )
  into table roots_modified.
elseif root is not initial.
  insert value #( orig = root real = root ) into table roots_modified.
endif.

eml_call_pre.

data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
if job->m_internal is initial.
  cl_abap_behv_job_base=>curr_eml_job = job.
endif.

" split mixed activities before passing job to SADL
job->disentangle( importing entangled_refs = data(erefs) ).

get_eml_processor.
eml_processor->modify( job ).

" merge result tables of split activities
job->entangle( erefs ).

switch_base_intf 'M'.

" === Start transaction control
cl_abap_behv_transaction_ctrl=>start( internal ).

if job->m_internal is initial.
  cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.
  xtrace_end_hier th.
endif.

eml_call_post.

endmethod.


method execute_permissions.

  data log type ref to cl_abap_behv_log.

  system-call debugger set system path on.           "#EC CI_SYSTEMCALL

  xtrace_beg_hier_eml th 'Permissions' 'EXECUTE_PERMISSIONS' dynamic 0 ##NO_TEXT.

  if failed   is supplied or
     reported is supplied .
    " ==== clear EML response fields
    clear failed.
    clear reported.
    " ==== create LOG object for transfer to EML response fields
    log = cl_abap_behv_log=>create_for_eml(
          exporting
            root         = root
            ref_failed   = cond #( when failed   is supplied then ref data( failed ) )
            ref_reported = cond #( when reported is supplied then ref data( reported ) )
            dynamic      = dynamic ).
  elseif ( log is not bound ) and ( job->m_has_ifeat is not initial or job->m_has_iauth is not initial ).
    log = cl_abap_behv_log=>create_for_eml( exporting root = root dynamic = 'X' ).
  endif.

  job->log = log.

  switch_intf_base 'i'.

  eml_call_pre.

  data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.
  cl_abap_behv_job_base=>curr_eml_job = job.

  job->disentangle( importing entangled_refs = data(erefs) ).

  get_eml_processor.
  call method eml_processor->permission_check exporting io_pjob  = job.

  job->entangle( erefs ).

  switch_base_intf 'i'.

  cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.

  eml_call_post.

  xtrace_end_hier th.

endmethod.


  method cleanup_krn by kernel module ab_km_behv_cleanup ignore.
  endmethod.


method IS_EXEMPTED.

is_exempted = xsdbool( value #( g_extab[ name = bdef_name ]-x optional ) bit-and exemption <> ex__null ).

endmethod.


  method MERGE_HANDLER_RESULTS.
    field-symbols <actv>           type ABP_BEHV_ACTIVITIES.

    if not handler->meth = 0.  " not %MANAGED

    if handler->kind ca op_chars_merge_itab. " INSTANCE FEATURES/AUTHORIZATION: GROUPS may exist

      data keyname type c length 30.
      data full_rec_new type ref to data.
      field-symbols <igrp_res_tab> type standard table.
      field-symbols <full_res_tab> type standard table.
      loop at params->* assigning field-symbol(<igrp_par>).
        data(actv_idx) = <igrp_par>-actv_idx.
        assign job->activities[ actv_idx ] to <actv>.
        " if references are equal, the parameter wasn't split
        check <igrp_par>-results <> <actv>-results.
        assign <igrp_par>-results->* to <igrp_res_tab>.
        " if results are empty, nothing needs to be merged
        check <igrp_res_tab> is not initial.
        assign <actv>-results->* to <full_res_tab>.
        if <full_res_tab> is initial.
          <full_res_tab> = corresponding #( <igrp_res_tab> ).
        else.
          create data full_rec_new like line of <full_res_tab>.
          assign full_rec_new->* to field-symbol(<full_rec_new>).
          if keyname is initial.
*        data(tabdescr) = cast cl_abap_tabledescr( cl_abap_typedescr=>describe_by_data( <full_res_tab> ) ).
*        data(keys) = tabdescr->get_keys( ).
*        if line_exists( keys[ name = CL_ABAP_BEHV=>co_key_name-pid ] ).
            assign component CL_ABAP_BEHV=>co_techfield_name-pid of structure <full_rec_new> to field-symbol(<pid>).
            if sy-subrc = 0.
              keyname = CL_ABAP_BEHV=>co_key_name-pid.
            else.
              keyname = CL_ABAP_BEHV=>co_key_name-entity.
            endif.
          endif.
          " merge result instances
          loop at <igrp_res_tab> assigning field-symbol(<igrp_rec>).
            move-corresponding <igrp_rec> to <full_rec_new>.
            read table <full_res_tab> from <full_rec_new> using key (keyname) assigning field-symbol(<full_rec_old>).
            if sy-subrc <> 0.
              insert <full_rec_new> into table <full_res_tab>.
            else.
              move-corresponding <igrp_rec> to <full_rec_old>.
            endif.
          endloop.
        endif.
      endloop.

    elseif handler->kind ca op_chars_merge_stru. " GLOBAL FEATURES/AUTHORIZATION: GROUPS may exist

      field-symbols <igrp_res_stru> type data.
      field-symbols <full_res_stru> type data.
      loop at params->* assigning <igrp_par>.
        actv_idx = <igrp_par>-actv_idx.
        assign job->activities[ actv_idx ] to <actv>.
        " if references are equal, the parameter wasn't split
        check <igrp_par>-results <> <actv>-results.
        assign <igrp_par>-results->* to <igrp_res_stru>.
        " if results are empty, nothing needs to be merged
        " check <igrp_res_tab> is not initial.
        assign <actv>-results->* to <full_res_stru>.
        move-corresponding <igrp_res_stru> to <full_res_stru>.
      endloop.

    endif.

  endif.

  endmethod.


  method read_relation_key_mapping.

    " -----------------------------------------------------------------
    " ---- Initialize result
    mapping-source_entity = relation-source_entity.
    mapping-source = cl_abap_behvdescr=>create_data(
        p_name = relation-source_entity
        p_root = root
        p_op   = cl_abap_behvdescr=>op_read ).
    mapping-target_entity = relation-target_entity.
    mapping-target = cl_abap_behvdescr=>create_data(
        p_name = relation-target_entity
        p_root = root
        p_op   = cl_abap_behvdescr=>op_read ).
    check source is not initial.

    field-symbols <mapping_source> type standard table.
    field-symbols <mapping_target> type standard table.
    assign mapping-source->* to <mapping_source>.
    assign mapping-target->* to <mapping_target>.

    " ---- common variables and field-symbols
    data l_corresp type ref to cl_abap_corresponding.
    data l_rjob type ref to cl_abap_behv_rjob.
    data l_keys type ref to data.
    field-symbols <keys> type standard table.
    data l_results type ref to data.
    field-symbols <results> type standard table.

    " ---- build name mapping and list of local names
    data l_corresp_map type cl_abap_corresponding=>mapping_table.
    data l_corresp_pair like line of l_corresp_map.
    data l_local_names type abp_field_name_tab.
    l_corresp_pair-kind = cl_abap_corresponding=>mapping_component.
    loop at relation-foreignkeys assigning field-symbol(<foreignkey_line>).
      insert <foreignkey_line>-local_name into table l_local_names.
      check <foreignkey_line>-local_name <> <foreignkey_line>-other_name.
      l_corresp_pair-srcname = <foreignkey_line>-local_name.
      l_corresp_pair-dstname = <foreignkey_line>-other_name.
      insert l_corresp_pair into table l_corresp_map.
    endloop.

    if relation-kind ca cl_abap_behv_load=>c_relation__is_assoc_based.
      " <KEYS>: key table for RBA
      l_keys = cl_abap_behvdescr=>create_data(
          p_op       =  cl_abap_behvdescr=>op_read_ba
          p_name     = relation-source_entity
          p_sub_name = relation-assoc_name ).
      assign l_keys->* to <keys>.

      if relation-foreignkeys is not initial.
        " target keys are subset of source keys, could be optimized if there's no %PID
        data           source_wa  type ref to data.
        field-symbols <source_wa> type any.
        field-symbols <pid>       type any.
        create data source_wa like line of source.
        assign source_wa->* to <source_wa>.
        assign component '%PID' of structure <source_wa> to <pid>.
        if sy-subrc = 0.
          loop at source into <source_wa>.
            if <pid> is not initial. " need RBA for entries with non-initial %PID
              append initial line to <keys> assigning field-symbol(<keys_wa>).
              move-corresponding <source_wa> to <keys_wa>.
            else. " can be optimized
              append initial line to <mapping_source> assigning field-symbol(<mapping_source_wa>).
              move-corresponding <source_wa> to <mapping_source_wa>.
            endif.
          endloop.
        else. " no %PID: all entries optimized
          move-corresponding source to <mapping_source>.
        endif.
      else. " not optimizable: RBA for all
        move-corresponding source to <keys>.
      endif.

      " ---------------------------------------------------------------
      " ---- Assoc-based relation, optimized: MOVE-CORRESPONDING
      if <mapping_source> is not initial.
        l_corresp = cl_abap_corresponding=>create(
            source      = <mapping_source>
            destination = <mapping_target>
            mapping     = l_corresp_map ).
        l_corresp->execute( exporting source = <mapping_source> changing destination = <mapping_target> ).
      endif.

      " -------------------------------------------------------------
      " ---- Assoc-based relation, non-optimized: RBA
      if <keys> is not initial.
        " Builds result (links table)
        l_results = cl_abap_behvdescr=>create_data(
            p_op       = cl_abap_behvdescr=>op_read_ba
            p_name     = relation-source_entity
            p_kind     = if_abap_behv=>typekind-link
            p_sub_name = relation-assoc_name ).
        assign l_results->* to <results>.
        " Build and execute RBA job
        l_rjob = cl_abap_behv_rjob=>create( in_local_mode = 'X' attrs_from = attrs_from ).
        l_rjob->log = log.
        l_rjob->add_retrievals(
            entity_name = relation-source_entity
            sub_name    = relation-assoc_name
            operation   = 'N'
            instances   = l_keys
            links       = l_results ).
        call_readers( exporting job = l_rjob ).
        if l_rjob->unhandled_activities is not initial.
          rjob_if_unhandled = l_rjob. " inform SADL about unhandled activities
        endif.
        " Convert results into MAPPING
        data l_result_line type ref to data.
        create data l_result_line like line of <results>.
        assign l_result_line->* to field-symbol(<result_line>).
        assign component 'SOURCE' of structure <result_line> to field-symbol(<rba_link_src>).
        assert sy-subrc = 0.
        assign component 'TARGET' of structure <result_line> to field-symbol(<rba_link_tgt>).
        assert sy-subrc = 0.
        loop at <results> into <result_line>.
          append initial line to <mapping_source> assigning field-symbol(<mapping_source_line>).
          move-corresponding <rba_link_src> to <mapping_source_line>.
          append initial line to <mapping_target> assigning field-symbol(<mapping_target_line>).
          move-corresponding <rba_link_tgt> to <mapping_target_line>.
        endloop.
      endif.

    else.

      " -------------------------------------------------------------
      " ---- Key field list-based mapping: READ + MOVE CORRESPONDING
      " Build keys
      l_keys = cl_abap_behvdescr=>create_data(
          p_op   = cl_abap_behvdescr=>op_read
          p_name = relation-source_entity ).
      assign l_keys->* to <keys>.
      loop at source assigning field-symbol(<source_line>).
        append initial line to <keys> assigning field-symbol(<key_line>).
        move-corresponding <source_line> to <key_line>.
        set flags <key_line> from names l_local_names.
      endloop.
      " Build result
      l_results = cl_abap_behvdescr=>create_data(
          p_op   = cl_abap_behvdescr=>op_read
          p_name = relation-source_entity
          p_kind = if_abap_behv=>typekind-result ).
      assign l_results->* to <results>.
      " Build and execute READ job
      l_rjob = cl_abap_behv_rjob=>create( in_local_mode = 'X' attrs_from = attrs_from ).
      l_rjob->log = log.
      l_rjob->add_retrievals(
          operation   = 'R'
          entity_name = relation-source_entity
          instances   = l_keys
          results     = l_results ).
      call_readers( exporting job = l_rjob ).
      if l_rjob->unhandled_activities is not initial.
        rjob_if_unhandled = l_rjob. " inform SADL about unhandled activities
      endif.
      " Convert results into MAPPING
      move-corresponding <results> to <mapping_source>.
      l_corresp = cl_abap_corresponding=>create(
          source      = <results>
          destination = <mapping_target>
          mapping     = l_corresp_map ).
      l_corresp->execute( exporting source = <results> changing destination = <mapping_target> ).

    endif.

  endmethod.


method GET_EXEMPTIONS.

if req_val is initial.
  exemptions = g_extab.
else.
  loop at g_extab assigning field-symbol(<e>).
    check <e>-x bit-and req_val <> ex__null.
    insert <e> into table exemptions.
  endloop.
endif.

endmethod.


method GET_TEST_DOUBLE.

check_test_double_allowed( ).

object = value #( mock_instances[ root_name = conv abp_root_entity_name( to_upper( root ) ) ]-object optional ).

endmethod.


method CHECK_SWITCHES_FOR_PERMISSIONS.
  "dump if a requested activity is disabled by a client dependent switch
  data actions_load type cl_abap_behv_load=>tt_action.
  data assocs_load type cl_abap_behv_load=>tt_assoc.
  data features_load type cl_abap_behv_load=>tt_feature.
  data extension_elems_load type cl_abap_behv_load=>tt_extension_element.

  loop at activities assigning field-symbol(<activity>).
    if <activity>-links is initial.
      continue.
    endif.
    assign <activity>-links->* to field-symbol(<links>).
    data(load) = cl_abap_behv_load=>get_load(
      exporting entity  = <activity>-entity_name
      importing actions      = actions_load
                associations = assocs_load
                features     = features_load
                extension_elements = extension_elems_load ).

    assign component '%ACTION' of structure <links> to field-symbol(<actions>).
    if sy-subrc eq 0.
      "check actions
      data(sd_actions) = cast cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( <actions> ) ).
      do.
        data(lindex) = sy-index.
        assign component lindex of structure <actions> to field-symbol(<action>).
        if sy-subrc ne 0.
          exit. "all components processed
        endif.
        if <action> is not initial.
          "dump if action is not part of the load
          data(name) = sd_actions->components[ lindex ]-name.
          read table actions_load with table key
            owner_entity = <activity>-entity_name name = name transporting no fields.
          if sy-subrc ne 0.
            data(action_name) = to_upper( '%ACTION-' && name ).
            raise shortdump type cx_abap_behv_runtime_error message e040 with action_name
              exporting tadir_key = cl_abap_behv_ctrl=>get_caller( ).
          endif.
        endif.
      enddo.
    endif.

    assign component '%ASSOC' of structure <links> to field-symbol(<assocs>).
    if sy-subrc eq 0.
      "check associations
      data(sd_assocs) = cast cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( <assocs> ) ).
      do.
        lindex = sy-index.
        assign component lindex of structure <assocs> to field-symbol(<assoc>).
        if sy-subrc ne 0.
          exit. "all components processed
        endif.
        if <assoc> is not initial.
          "dump if association is not part of the load
          name = sd_assocs->components[ lindex ]-name.
          read table assocs_load with table key
            source_entity = <activity>-entity_name name = name transporting no fields.
          if sy-subrc ne 0.
            data(assoc_name) = to_upper( '%ASSOC-' && name ).
            raise shortdump type cx_abap_behv_runtime_error message e040 with assoc_name
              exporting tadir_key = cl_abap_behv_ctrl=>get_caller( ).
          endif.
        endif.
      enddo.
    endif.

    assign component '%FIELD' of structure <links> to field-symbol(<fields>).
    if sy-subrc eq 0.
      "check associations
      data(sd_fields) = cast cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( <fields> ) ).
      do.
        lindex = sy-index.
        assign component lindex of structure <fields> to field-symbol(<field>).
        if sy-subrc ne 0.
          exit. "all components processed
        endif.
        if <field> is not initial.
          "dump if field is part an extension and has no feature load
          name = sd_fields->components[ lindex ]-name.
          read table extension_elems_load with table key
            owner_entity = <activity>-entity_name element_kind = 'F' element = name transporting no fields.
          if sy-subrc eq 0. "field is part of an extenstion ...
            read table features_load with table key
              owner_entity = <activity>-entity_name element_kind = 'F' element = name transporting no fields.
            if sy-subrc ne 0. "but has no feature load
              data(field_name) = to_upper( '%FIELD-' && name ).
              raise shortdump type cx_abap_behv_runtime_error message e040 with field_name
                exporting tadir_key = cl_abap_behv_ctrl=>get_caller( ).
            endif.
          endif.
        endif.
      enddo.
    endif.


  endloop.
endmethod.


  method get_1st_saver_call_cycle.
    data prev type string.

    if curr <> find. " curr = find => cycle found, no need to search
      assign saver_collector->saver_call_graph[ saver = curr ] to field-symbol(<curr>).
      check sy-subrc = 0. " node not (yet) in graph: cannot be part of cycle => done

      read table <curr>-called_by with table key table_line = find transporting no fields.
      if sy-subrc <> 0. " FIND node directly in CALLED_BY: cycle found (processed below)

        loop at <curr>-called_by assigning field-symbol(<called_by>).
          prev = get_1st_saver_call_cycle( curr = <called_by> find = find ).
          check prev is not initial.
          exit. " exit loop if cycle found
        endloop.

        check prev is not initial. " no cycle: done

      endif.

    endif.

    " cycle found: build result
    if prev is initial.
      prev = objectdescr( find ).
    endif.
    cycle = |{ prev } -> { objectdescr( curr ) }|.
  endmethod.


method SPLIT_DSP_HANDLER.

" - Check all DSP handler instances
" - Check all parameters of DSP handler instance
" - Collect all non-draft actions/functions among them
" - If none exists: Done, everything is CSP delegation
" - Else split parameters into chunks of "CSP" vs "direct action/function"
" - Replace original DSP handler instance with one instance per chunk

constants: begin of draft_actions,
             e type cl_abap_behv_load=>t_action_kind value cl_abap_behv_load=>c_action_edit,
             a type cl_abap_behv_load=>t_action_kind value cl_abap_behv_load=>c_action_activate,
             d type cl_abap_behv_load=>t_action_kind value cl_abap_behv_load=>c_action_discard,
             r type cl_abap_behv_load=>t_action_kind value cl_abap_behv_load=>c_action_resume,
           end of draft_actions.
constants: begin of action_ops,
             A type abp_behv_op value cl_abap_behv_ctrl=>op-action,
             E type abp_behv_op value cl_abap_behv_ctrl=>op-evaluate,
           end of action_ops.

types: begin of t_chunk,
         from     type i,
         to       type i,
         delegate type c length 1,
       end of t_chunk.

data param_indx  type sorted table of i with unique key table_line.
data action_indx type sorted table of i with unique key table_line.
data chunks      type standard table of t_chunk with empty key.
data all_actions type cl_abap_behv_load=>tt_action.
data last_root   type abp_root_entity_name.

field-symbols <actv>  type abp_behv_activities.
field-symbols <hdlr>  type t_handler.
field-symbols <param> type t_handler_param.
field-symbols <chunk> type t_chunk.

data(hdlr_idx) = 1.

do.  " inspect original DSP handler(s)

  assign handlers[ hdlr_idx ] to <hdlr>.
  if sy-subrc <> 0.  exit.  endif.
  if <hdlr>-handler_idx <> cl_abap_behv_ctrl=>mki-csp_draft.
    add 1 to hdlr_idx.  continue.
  endif.

  data(dsp_hdlr)  = cast cl_abap_behv_handler_mngd_dsp( <hdlr>-handler ).
  data(orig_kind) = cast cl_abap_behavior_handler( dsp_hdlr )->kind.
  data(orig_root) = dsp_hdlr->m_root.
  clear: param_indx, action_indx, chunks, all_actions.

  " check DSP handler's parameters for non-draft actions/functions
  loop at <hdlr>-params assigning <param> where instances is not initial.
    insert <param>-actv_idx into table param_indx.
    check <param>-op ca action_ops.
    assign job->activities[ <param>-actv_idx ] to <actv>.
    if orig_kind = 'M'.
      " for Modify, draft actions must be distinguished from other actions
      if all_actions is initial or orig_root <> last_root.
        cl_abap_behv_load=>get_load( exporting entity = orig_root all = 'X'
                                     importing actions = all_actions ).
        last_root = orig_root.
      endif.
      assign all_actions[ owner_entity = <actv>-entity_name name = <actv>-sub_name ] to field-symbol(<act>).
      if sy-subrc = 0 and ( draft_actions ca <act>-properties-kind or
         <act>-properties-kind = cl_abap_behv_load=>c_action_determine and <act>-name = 'PREPARE' ).
        continue.  " draft action: to be delegated to CSP
      endif.
    endif.
    insert <param>-actv_idx into table action_indx.  " other action: to be dispatched w/o CSP
  endloop.

  if action_indx is initial.
    add 1 to hdlr_idx.
    continue.  " nothing to do, this DSP instance works exclusively with CSP delegation
  endif.

  " determine chunks of "CSP" vs. "non-CSP" activities (use activities order)
  data(n_actvs) = lines( job->activities ).
  data(actv_idx) = 1.
  while actv_idx <= n_actvs.
    if not line_exists( param_indx[ table_line = actv_idx ] ).
      add 1 to actv_idx.  continue.  " not a parameter to DSP
    endif.
    data(deleg) = xsdbool( not line_exists( action_indx[ table_line = actv_idx ] ) ).
    insert value #( from = actv_idx to = actv_idx delegate = deleg )
     into table chunks assigning <chunk>.
    add 1 to actv_idx.
    while actv_idx <= n_actvs and
" allow "non-CSP" chunks of size 1 only:
     deleg = 'X' and not line_exists( action_indx[ table_line = actv_idx ] ).
" allow "non-CSP" chunks of size >=2:
"   if actions are implemented by distinct handlers, CID_REF resolution won't run
"   between calls [when under a projection], so better call them one by one
*     deleg = xsdbool( not line_exists( action_indx[ table_line = actv_idx ] ) ).
      add 1 to <chunk>-to.  add 1 to actv_idx.
    endwhile.
  endwhile.

  " replace original DSP handler with one instance for each chunk
  data(orig_hdlr) = <hdlr>.
  unassign <hdlr>.  delete handlers index hdlr_idx.
  loop at chunks assigning <chunk>.
    insert orig_hdlr into handlers index hdlr_idx assigning <hdlr>.
    if <chunk>-delegate is initial.
      data(new_hdlr) = new cl_abap_behv_handler_mngd_dsp( ).
      cast cl_abap_behavior_handler( new_hdlr )->kind = orig_kind.
      new_hdlr->m_root           = orig_root.
      new_hdlr->m_managed_kind   = dsp_hdlr->m_managed_kind.
      new_hdlr->m_not_delegating = 'X'.  " !
      <hdlr>-handler = new_hdlr.
    endif.
    loop at <hdlr>-params assigning <param>.
      if <param>-actv_idx between <chunk>-from and <chunk>-to.
        continue.
      endif.
      delete <hdlr>-params.
    endloop.
    add 1 to hdlr_idx.
  endloop.

enddo.  " inspect original DSP handler(s)

endmethod.


method _EXECUTE_ACTIVATE.

if job->M_DRAFT_ACTIVATE is initial
 or job is not instance of cl_abap_behv_job.  " e.g. NUMBERING job
  return.
endif.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

switch_intf_base 'M'.

*data(prev_eml_job) = cl_abap_behv_job_base=>curr_eml_job.

get_eml_processor.
eml_processor->modify( cast #( job ) ).

switch_base_intf 'M'.

*cl_abap_behv_job_base=>curr_eml_job = prev_eml_job.

activate_done = 'X'.

endmethod.


method _EXECUTE_INTERNAL_MODIFY.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

switch_intf_base 'M'.

job->m_internal = internal_mode.

get_eml_processor.
eml_processor->modify( job ).

switch_base_intf 'M'.

endmethod.


method _EXECUTE_INTERNAL_READ.

system-call debugger set system path on.  "#EC CI_SYSTEMCALL

switch_intf_base 'M'.

job->m_internal = internal_mode.

get_eml_processor.
eml_processor->read( job ).

switch_base_intf 'M'.

endmethod.
ENDCLASS.